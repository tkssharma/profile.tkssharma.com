const blogData ={
  "status": "ok",
  "feed": {
      "url": "https://medium.com/feed/@tkssharma",
      "title": "Stories by Tarun Sharma on Medium",
      "link": "https://medium.com/@tkssharma?source=rss-9bea52c4baff------2",
      "author": "",
      "description": "Stories by Tarun Sharma on Medium",
      "image": "https://cdn-images-1.medium.com/fit/c/150/150/0*5l2lWIXJn5av6Lh5.jpg"
  },
  "items": [
      {
          "title": "Learning Typescript in Depth 3.x.x",
          "pubDate": "2018-10-28 01:41:16",
          "link": "https://medium.com/@tkssharma/learning-typescript-in-depth-3-x-x-4aa427e98fc6?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/4aa427e98fc6",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*0r4CMSULZkUCMfv-hiFU7A.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0r4CMSULZkUCMfv-hiFU7A.png\"></figure><p>Since 2012, TypeScript has been a popular choice for programmers coming to JavaScript from more structured languages (like C++ or Java). But itâ€™s also been largely dismissed by those native to the JavaScript world.</p>\n<p>You may have heard that the Angular team recently <a href=\"https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8\">switched to TypeScript for Angular 2</a>. So have the teams behind <a href=\"https://github.com/ReactiveX/rxjs\">RxJS</a>, <a href=\"https://blog.ionic.io/announcing-ionic-2-0-0-final/\">Ionic</a>, <a href=\"https://cycle.js.org/\">Cycle.js</a>, <a href=\"https://github.com/palantir/blueprint\">Blueprint</a>, <a href=\"https://dojotoolkit.org/community/roadmap/vision.html\">Dojo</a>, <a href=\"https://github.com/NativeScript/NativeScript\">NativeScript</a>, <a href=\"https://github.com/palantir/plottable\">Plottable</a>, andÂ others.</p>\n<p>If youâ€™ve been in JavaScript/Node.js land for a while, itâ€™s easy to assume that the shot-callers for these projects have lost their minds. Or maybe that they were paid off by Microsoft. ğŸ‘€</p>\n<p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6iZRxm29jTTDu1z91fo0iA.jpeg\"></figure><p>And if you havenâ€™t been watching closely, you may have missed TypeScriptâ€™s amazing progress over the past year (and even the past fewÂ months).</p>\n<p><strong>If youâ€™re still thinking â€œTypeScript is kinda like CoffeeScript, right?â€â€Šâ€”â€Šthis article is forÂ you.</strong></p>\n<p>Typescript is something which is adding types in your application to make it full proof application.</p>\n<h3>TypeScript is JavaScript with betterÂ linting</h3>\n<p>Probably one of the most common concerns with the idea of using TypeScript is that it isnâ€™t <em>pure</em> JavaScript. Because TypeScript is its own language, itâ€™s assumed your code will be transpiled into a messy glob which youâ€™ll someday be forced toÂ debug.</p>\n<p>Besides TypeScript being extremely well-tested and widely in use, itâ€™s worth noting that depending on your configuration, very little â€œtranspilingâ€ is actually happening (if any). TypeScript is just Javascript with optionalÂ typings.</p>\n<a href=\"https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href\">https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href</a><a href=\"https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href\">https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href</a><p>letâ€™s Learn Typescript buildingÂ blocks</p>\n<h4>Typescript Compiler</h4>\n<p>There are two main ways to get the TypeScript tools:</p>\n<ul>\n<li>Via npm (the Node.js packageÂ manager)</li>\n<li>By installing TypeScriptâ€™s Visual StudioÂ plugins</li>\n</ul>\n<p>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didnâ€™t install TypeScript with Visual Studio, you can still <a href=\"https://www.typescriptlang.org/#download-links\">downloadÂ it</a>.</p>\n<p>For NPMÂ users:</p>\n<pre>&gt; npm install -g typescript</pre>\n<h3>Building your first TypeScript file</h3>\n<p>In your editor, type the following JavaScript code in greeter.ts:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Compiling yourÂ code</h3>\n<p>We used aÂ .ts extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</p>\n<p>At the command line, run the TypeScript compiler:</p>\n<pre>tsc greeter.ts</pre>\n<p>The result will be a file greeter.js which contains the same JavaScript that you fed in. Weâ€™re up and running using TypeScript in our JavaScript app!</p>\n<p>Now we can start taking advantage of some of the new tools TypeScript offers. Add aÂ : string type annotation to the â€˜personâ€™ function argument as shownÂ here:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Type annotations</h3>\n<p>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an arrayÂ instead:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = [0, 1, 2];</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<p>Re-compiling, youâ€™ll now see anÂ error:</p>\n<pre>error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.</pre>\n<p>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations youÂ provide.</p>\n<p>Notice that although there were errors, the greeter.js file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</p>\n<a href=\"https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href\">https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href</a><p>Union Type, optional type, array literal withÂ types</p>\n<a href=\"https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href\">https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href</a><p>The non-primitive group includes void, string literal, tuple, any, unknown, andÂ never</p>\n<h3>Void &amp; NeverTypes</h3>\n<p>In TypeScript 2.0, a new primitive type called never was introduced. It represents the type of values that never occur. The never type is used in the following twoÂ places:</p>\n<ul>\n<li>As the return type of <strong>functions that neverÂ return</strong>.</li>\n<li>As the type of variables under <strong>type guards that are neverÂ true</strong>.</li>\n</ul>\n<h3>Union Types</h3>\n<p>Union types are closely related to intersection types, but they are used very differently. Occasionally, youâ€™ll run into a library that expects a parameter to be either a number or a string. For instance, take the following function:</p>\n<pre>/**<br> * Takes a string and adds \"padding\" to the left.<br> * If 'padding' is a string, then 'padding' is appended to the left side.<br> * If 'padding' is a number, then that number of spaces is added to the left side.<br> */<br><strong>function</strong> <strong>padLeft</strong>(value: string, padding: any) {<br><strong>if</strong> (<strong>typeof</strong> padding === \"number\") {<br><strong>return</strong> Array(padding + 1).join(\" \") + value;<br>    }<br><strong>if</strong> (<strong>typeof</strong> padding === \"string\") {<br><strong>return</strong> padding + value;<br>    }<br><strong>throw</strong> <strong>new</strong> Error(`Expected string or number, got '${padding}'.`);<br>}</pre>\n<pre>padLeft(\"Hello world\", 4); // returns \"    Hello world\"</pre>\n<p>The problem with padLeft is that its padding parameter is typed as any. That means that we can call it with an argument thatâ€™s neither a number nor a string, but TypeScript will be okay withÂ it.</p>\n<a href=\"https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href\">https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href</a><h3>Enums</h3>\n<p>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</p>\n<h3>Numeric enums</h3>\n<p>Weâ€™ll first start off with numeric enums, which are probably more familiar if youâ€™re coming from other languages. An enum can be defined using the enumÂ keyword.</p>\n<pre><strong>enum</strong> Direction {<br>    Up = 1,<br>    Down,<br>    Left,<br>    Right,<br>}</pre>\n<p>Above, we have a numeric enum where Up is initialized with 1. All of the following members are auto-incremented from that point on. In other words, Direction.Up has the value 1, Down has 2, Left has 3, and Right hasÂ 4.</p>\n<a href=\"https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href\">https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href</a><h3>Interfaces</h3>\n<p>One of TypeScriptâ€™s core principles is that type-checking focuses on the <em>shape</em> that values have. This is sometimes called â€œduck typingâ€ or â€œstructural subtypingâ€. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of yourÂ project.</p>\n<h4>Our First Interface</h4>\n<p>The easiest way to see how interfaces work is to start with a simpleÂ example:</p>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: { label: string }) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<p>The type-checker checks the call to printLabel. The printLabel function has a single parameter that requires that the object passed in has a property called label of type string. Notice that our object actually has more properties than this, but the compiler only checks that <em>at least</em> the ones required are present and match the types required. There are some cases where TypeScript isnâ€™t as lenient, which weâ€™ll cover in aÂ bit.</p>\n<p>We can write the same example again, this time using an interface to describe the requirement of having the labelproperty that is aÂ string:</p>\n<pre><strong>interface</strong> LabelledValue {<br>    label: string;<br>}</pre>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: LabelledValue) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<a href=\"https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href\">https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href</a><h3>Generics&lt;T&gt;</h3>\n<p>To start off, letâ€™s do the â€œhello worldâ€ of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echoÂ command.</p>\n<p>Without generics, we would either have to give the identity function a specificÂ type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: number): <strong>number</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>Or, we could describe the identity function using the anyÂ type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: any): <strong>any</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>While using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</p>\n<p>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a <em>type variable</em>, a special kind of variable that works on types rather thanÂ values.</p>\n<pre><strong>function</strong> <strong>identity</strong>&lt;<strong>T</strong>&gt;(arg: T): <strong>T</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>Weâ€™ve now added a type variable T to the identity function. This T allows us to capture the type the user provides (e.g. number), so that we can use that information later. Here, we use T again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out theÂ other.</p>\n<p>We say that this version of the identity function is generic, as it works over a range of types. Unlike using any, itâ€™s also just as precise (ie, it doesnâ€™t lose any information) as the first identity function that used numbers for the argument and returnÂ type.</p>\n<p>Once weâ€™ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</p>\n<a href=\"https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href\">https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href</a><h4>More Available onÂ Scrimba</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*OYcK0HPBQbr5W3KbmasOhw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*aTGEcFaBl4XUfKqSq7gp8g.png\"></figure><p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4aa427e98fc6\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0r4CMSULZkUCMfv-hiFU7A.png\"></figure><p>Since 2012, TypeScript has been a popular choice for programmers coming to JavaScript from more structured languages (like C++ or Java). But itâ€™s also been largely dismissed by those native to the JavaScript world.</p>\n<p>You may have heard that the Angular team recently <a href=\"https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8\">switched to TypeScript for Angular 2</a>. So have the teams behind <a href=\"https://github.com/ReactiveX/rxjs\">RxJS</a>, <a href=\"https://blog.ionic.io/announcing-ionic-2-0-0-final/\">Ionic</a>, <a href=\"https://cycle.js.org/\">Cycle.js</a>, <a href=\"https://github.com/palantir/blueprint\">Blueprint</a>, <a href=\"https://dojotoolkit.org/community/roadmap/vision.html\">Dojo</a>, <a href=\"https://github.com/NativeScript/NativeScript\">NativeScript</a>, <a href=\"https://github.com/palantir/plottable\">Plottable</a>, andÂ others.</p>\n<p>If youâ€™ve been in JavaScript/Node.js land for a while, itâ€™s easy to assume that the shot-callers for these projects have lost their minds. Or maybe that they were paid off by Microsoft. ğŸ‘€</p>\n<p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6iZRxm29jTTDu1z91fo0iA.jpeg\"></figure><p>And if you havenâ€™t been watching closely, you may have missed TypeScriptâ€™s amazing progress over the past year (and even the past fewÂ months).</p>\n<p><strong>If youâ€™re still thinking â€œTypeScript is kinda like CoffeeScript, right?â€â€Šâ€”â€Šthis article is forÂ you.</strong></p>\n<p>Typescript is something which is adding types in your application to make it full proof application.</p>\n<h3>TypeScript is JavaScript with betterÂ linting</h3>\n<p>Probably one of the most common concerns with the idea of using TypeScript is that it isnâ€™t <em>pure</em> JavaScript. Because TypeScript is its own language, itâ€™s assumed your code will be transpiled into a messy glob which youâ€™ll someday be forced toÂ debug.</p>\n<p>Besides TypeScript being extremely well-tested and widely in use, itâ€™s worth noting that depending on your configuration, very little â€œtranspilingâ€ is actually happening (if any). TypeScript is just Javascript with optionalÂ typings.</p>\n<a href=\"https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href\">https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href</a><a href=\"https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href\">https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href</a><p>letâ€™s Learn Typescript buildingÂ blocks</p>\n<h4>Typescript Compiler</h4>\n<p>There are two main ways to get the TypeScript tools:</p>\n<ul>\n<li>Via npm (the Node.js packageÂ manager)</li>\n<li>By installing TypeScriptâ€™s Visual StudioÂ plugins</li>\n</ul>\n<p>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didnâ€™t install TypeScript with Visual Studio, you can still <a href=\"https://www.typescriptlang.org/#download-links\">downloadÂ it</a>.</p>\n<p>For NPMÂ users:</p>\n<pre>&gt; npm install -g typescript</pre>\n<h3>Building your first TypeScript file</h3>\n<p>In your editor, type the following JavaScript code in greeter.ts:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Compiling yourÂ code</h3>\n<p>We used aÂ .ts extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</p>\n<p>At the command line, run the TypeScript compiler:</p>\n<pre>tsc greeter.ts</pre>\n<p>The result will be a file greeter.js which contains the same JavaScript that you fed in. Weâ€™re up and running using TypeScript in our JavaScript app!</p>\n<p>Now we can start taking advantage of some of the new tools TypeScript offers. Add aÂ : string type annotation to the â€˜personâ€™ function argument as shownÂ here:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Type annotations</h3>\n<p>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an arrayÂ instead:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = [0, 1, 2];</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<p>Re-compiling, youâ€™ll now see anÂ error:</p>\n<pre>error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.</pre>\n<p>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations youÂ provide.</p>\n<p>Notice that although there were errors, the greeter.js file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</p>\n<a href=\"https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href\">https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href</a><p>Union Type, optional type, array literal withÂ types</p>\n<a href=\"https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href\">https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href</a><p>The non-primitive group includes void, string literal, tuple, any, unknown, andÂ never</p>\n<h3>Void &amp; NeverTypes</h3>\n<p>In TypeScript 2.0, a new primitive type called never was introduced. It represents the type of values that never occur. The never type is used in the following twoÂ places:</p>\n<ul>\n<li>As the return type of <strong>functions that neverÂ return</strong>.</li>\n<li>As the type of variables under <strong>type guards that are neverÂ true</strong>.</li>\n</ul>\n<h3>Union Types</h3>\n<p>Union types are closely related to intersection types, but they are used very differently. Occasionally, youâ€™ll run into a library that expects a parameter to be either a number or a string. For instance, take the following function:</p>\n<pre>/**<br> * Takes a string and adds \"padding\" to the left.<br> * If 'padding' is a string, then 'padding' is appended to the left side.<br> * If 'padding' is a number, then that number of spaces is added to the left side.<br> */<br><strong>function</strong> <strong>padLeft</strong>(value: string, padding: any) {<br><strong>if</strong> (<strong>typeof</strong> padding === \"number\") {<br><strong>return</strong> Array(padding + 1).join(\" \") + value;<br>    }<br><strong>if</strong> (<strong>typeof</strong> padding === \"string\") {<br><strong>return</strong> padding + value;<br>    }<br><strong>throw</strong> <strong>new</strong> Error(`Expected string or number, got '${padding}'.`);<br>}</pre>\n<pre>padLeft(\"Hello world\", 4); // returns \"    Hello world\"</pre>\n<p>The problem with padLeft is that its padding parameter is typed as any. That means that we can call it with an argument thatâ€™s neither a number nor a string, but TypeScript will be okay withÂ it.</p>\n<a href=\"https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href\">https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href</a><h3>Enums</h3>\n<p>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</p>\n<h3>Numeric enums</h3>\n<p>Weâ€™ll first start off with numeric enums, which are probably more familiar if youâ€™re coming from other languages. An enum can be defined using the enumÂ keyword.</p>\n<pre><strong>enum</strong> Direction {<br>    Up = 1,<br>    Down,<br>    Left,<br>    Right,<br>}</pre>\n<p>Above, we have a numeric enum where Up is initialized with 1. All of the following members are auto-incremented from that point on. In other words, Direction.Up has the value 1, Down has 2, Left has 3, and Right hasÂ 4.</p>\n<a href=\"https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href\">https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href</a><h3>Interfaces</h3>\n<p>One of TypeScriptâ€™s core principles is that type-checking focuses on the <em>shape</em> that values have. This is sometimes called â€œduck typingâ€ or â€œstructural subtypingâ€. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of yourÂ project.</p>\n<h4>Our First Interface</h4>\n<p>The easiest way to see how interfaces work is to start with a simpleÂ example:</p>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: { label: string }) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<p>The type-checker checks the call to printLabel. The printLabel function has a single parameter that requires that the object passed in has a property called label of type string. Notice that our object actually has more properties than this, but the compiler only checks that <em>at least</em> the ones required are present and match the types required. There are some cases where TypeScript isnâ€™t as lenient, which weâ€™ll cover in aÂ bit.</p>\n<p>We can write the same example again, this time using an interface to describe the requirement of having the labelproperty that is aÂ string:</p>\n<pre><strong>interface</strong> LabelledValue {<br>    label: string;<br>}</pre>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: LabelledValue) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<a href=\"https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href\">https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href</a><h3>Generics&lt;T&gt;</h3>\n<p>To start off, letâ€™s do the â€œhello worldâ€ of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echoÂ command.</p>\n<p>Without generics, we would either have to give the identity function a specificÂ type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: number): <strong>number</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>Or, we could describe the identity function using the anyÂ type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: any): <strong>any</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>While using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</p>\n<p>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a <em>type variable</em>, a special kind of variable that works on types rather thanÂ values.</p>\n<pre><strong>function</strong> <strong>identity</strong>&lt;<strong>T</strong>&gt;(arg: T): <strong>T</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>Weâ€™ve now added a type variable T to the identity function. This T allows us to capture the type the user provides (e.g. number), so that we can use that information later. Here, we use T again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out theÂ other.</p>\n<p>We say that this version of the identity function is generic, as it works over a range of types. Unlike using any, itâ€™s also just as precise (ie, it doesnâ€™t lose any information) as the first identity function that used numbers for the argument and returnÂ type.</p>\n<p>Once weâ€™ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</p>\n<a href=\"https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href\">https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href</a><h4>More Available onÂ Scrimba</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*OYcK0HPBQbr5W3KbmasOhw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*aTGEcFaBl4XUfKqSq7gp8g.png\"></figure><p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4aa427e98fc6\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "nodejs",
              "reactjs",
              "js",
              "typescript",
              "javascript"
          ]
      },
      {
          "title": "Learn Node JS Beginner to Intermediate Level â€” Free Learning YouTube Videos",
          "pubDate": "2018-10-01 12:30:58",
          "link": "https://medium.com/@tkssharma/learn-node-js-beginner-to-intermediate-level-free-learning-youtube-videos-df79264ed0cf?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/df79264ed0cf",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/1000/1*fsseXIPGEhwmg6kfgXyIjA.jpeg",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*fsseXIPGEhwmg6kfgXyIjA.jpeg\"></figure><a href=\"https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href\">https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href</a><a href=\"https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href\">https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href</a><a href=\"https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href\">https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href</a><a href=\"https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href\">https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href</a><a href=\"https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href\">https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href</a><a href=\"https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href\">https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href</a><a href=\"https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href\">https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href</a><a href=\"https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href\">https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href</a><a href=\"https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href\">https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href</a><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df79264ed0cf\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*fsseXIPGEhwmg6kfgXyIjA.jpeg\"></figure><a href=\"https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href\">https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href</a><a href=\"https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href\">https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href</a><a href=\"https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href\">https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href</a><a href=\"https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href\">https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href</a><a href=\"https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href\">https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href</a><a href=\"https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href\">https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href</a><a href=\"https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href\">https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href</a><a href=\"https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href\">https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href</a><a href=\"https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href\">https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href</a><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df79264ed0cf\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "nodejs",
              "node-js-tutorial",
              "learning",
              "javascript",
              "youtube-video"
          ]
      },
      {
          "title": "JavaScript ES6 â€” write new way",
          "pubDate": "2018-09-25 02:08:29",
          "link": "https://medium.com/@tkssharma/javascript-es6-write-new-way-1dcb7d40952c?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/1dcb7d40952c",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/779/1*67201m2bx5fRSzP2lbXLqA.png",
          "description": "\n<p>JavaScript ES6 brings new syntax and new awesome features to make your code more modern and more readable. It allows you to write less code and do more. ES6 introduces us to many great features like arrow functions, template strings, class destruction, Modulesâ€¦ and more. Letâ€™s take aÂ look.</p>\n<h3>const andÂ let</h3>\n<p>const is a new keyword in ES6 for declaring variables. const is more powerful than var. Once used, the variable canâ€™t be reassigned. In other words, itâ€™s an <strong>immutable variable </strong>except when it used withÂ objects.</p>\n<p>This is really useful for targeting the selectors. For example, when we have a single button that fires an event, or when you want to select an HTML element in JavaScript, use const instead of var. This is because var is â€˜hoistedâ€™. Itâ€™s always preferable to use const when donâ€™t want to reassign the variableÂ .</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/779/1*67201m2bx5fRSzP2lbXLqA.png\"></figure><p>In the code above, const will not change and cannot be reassigned. If you try to give it a new value, it will return you anÂ error.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/561/1*6hP1VNVQ_8Siv6HQyju9cA.png\"></figure><p>let can be reassigned and take new value. It creates a <strong>mutable variable</strong>.</p>\n<p>let is the same as const in that both are blocked-scope. It means that the variable is only available within itsÂ scope.</p>\n<h3>Arrow functions</h3>\n<p>The arrow function is really awesome, and makes your code more readable, more structured, and look like modern code. Instead of usingÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/763/1*fjf4cc0kHb27cRlnSrmwcQ.png\"></figure><p>Use this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*ol3OyEl4zCwGdLT5OOmyRg.png\"></figure><p>As you see, the arrow function seems more readable and clean! You wonâ€™t need to use the old syntaxÂ anymore.</p>\n<p>Also, you can use Arrow function with map, filter, and reduce<strong> </strong>built-in functions.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/943/1*ryJby1pq8wA3EyIp1sRNTQ.png\"></figure><p>The map function with arrows looks more clear and readable than map in ES5. With ES6 you can write shorter and smarter code. You can use the same with filter andÂ reduce.</p>\n<h3>Template Literals</h3>\n<p>Template literals or template strings are pretty cool. We donâ€™t have to use the plus (+) operator to concatenate strings, or when we want to use a variable inside aÂ string.</p>\n<p>The oldÂ syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/925/1*RxqfDIe2jNG4E1KUD3Mw-w.png\"></figure><p>With new ES6Â syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/924/1*16Yxl9wpSuttbJMuFsiNYA.png\"></figure><p>So simple! Itâ€™s a really huge difference between the old syntax and ES6. When playing with strings, the literal string in ES6 looks more organized and well structured thanÂ ES5.</p>\n<h3>Default parameters</h3>\n<p>When I work in PHP, I usually use default parameters. These allow you to define a parameter inÂ advance.</p>\n<p>So, when you forget to write the parameter, it wonâ€™t return an undefined error because the parameter is already defined in the default. So when you run your function with a missed parameter, it will take the value of the default parameter, and it will not return anÂ error!</p>\n<p>Look at thisÂ example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*YWalapv4SCVHEjp32G6SOQ.png\"></figure><p>The function above returns undefined because we forgot to give it the second parameter.</p>\n<p>But if we used the default parameter, it wonâ€™t return undefined, and it will use its value when we forget to assign a parameter!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/907/1*PYEr_IMC1Uu6m4VFETEfRw.png\"></figure><p>As you see, the function returns a value even though we missed the second parameter. Now with the default parameter, we can handle the error inÂ advance.</p>\n<h3>Array and object destructing</h3>\n<p>Destruction makes the assignment of the values of an array or object to the new variableÂ easier.</p>\n<p>The oldÂ syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*-_gztZYidNjUmczN03vHLg.png\"></figure><p>With ES6Â syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/703/1*xBodgoxrytIjNxXU42QTng.png\"></figure><p>With ES5, we have to assign each value to each variable. With ES6, we just put our values within curly brackets to get any property of theÂ object.</p>\n<p>Note:<strong> </strong>if you assign a variable that is not identical to the name of property, it will return undefined. For example, if the name of the property is name and we assign it to a username<strong> </strong>variable,<strong> </strong>it will return undefined.</p>\n<p>We always have to name the variable the same as the name of the property. But in case we want to rename the variable, we can use the colonÂ :Â instead.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*p1IcVKmbO5pVANRn3kATKA.png\"></figure><p>For the array, we use the same syntax as the object. We have just to replace the curly brackets with square brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*zXKJpPbOh-T-0EYDjRS7-g.png\"></figure><h3>Import andÂ export</h3>\n<p>Using import and export in your JavaScript application makes it more powerful. They allow you to create separate and reusable components.</p>\n<p>If you are familiar with any JavaScript MVC framework, you will see that they use import and export to handle the components most of the time. So how do they reallyÂ work?</p>\n<p>It is simple! export allows you to export a module to be used in another JavaScript component. We use import to import that module to use it in our component.</p>\n<p>For example, we have two files. The first is named detailComponent.js<strong> </strong>and the second is named<strong> </strong>homeComponent.js.</p>\n<p>In detailComponent.js<strong> </strong>we are going to export the detail function.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*8d92-RWEx0ygfE22dVWGDA.png\"></figure><p>And if we want to use this function in homeComponent.js,<strong> </strong>we will just useÂ import.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*9BZyWlYn4AYUiJxHjGRSlg.png\"></figure><p>If we want to import more than one module, we just put them within curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VYV52kLrNzZB5-hvartRxA.png\"></figure><p>So cool, isnâ€™tÂ it?!</p>\n<h3>Promises</h3>\n<p>Promises are a new feature of ES6. Itâ€™s a method to write asynchronous code. It can be used when, for example, we want to fetch data from an API, or when we have a function that takes time to be executed. Promises make it easier to solve the problem, so letâ€™s create our firstÂ Promise!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1011/1*RPGNKVoCRxnA-uVv9Kl4mA.png\"></figure><p>If you log your console, it will return a Promise. So, if we want to execute a function after data is fetched, we will use a Promise. The Promise takes two parameters: resolve and reject to handle an expectedÂ error.</p>\n<p>Note: the fetch function returns a PromiseÂ itself!</p>\n<pre><em>const</em> url='https://jsonplaceholder.typicode.com/posts';</pre>\n<pre><em>const</em> getData=(<em>url</em>)<em>=&gt;</em>{<br>return fetch(url);<br>}</pre>\n<pre>getData(url).<br>then(<em>data=&gt;</em> data.json()).<br>then(<em>result=&gt;</em> <em>console</em>.log(result));</pre>\n<p>Now if you log your console it will return an array ofÂ data.</p>\n<h3>Rest parameter and SpreadÂ operator</h3>\n<p><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Functions/rest_parameters\">The rest parameter</a>s are used to get the argument of an array, and return a newÂ array.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/961/1*8ohFXBJT4xFXwAScL5fy_g.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/976/1*v_5auLvegq0LqezITsIJyw.png\"></figure><p>The spread operator has the same syntax as the rest parameter, but the spread operator takes the Array itself and not just the arguments. We can use the Spread parameter to get the values of an Array, instead of using a for loop or any otherÂ method.</p>\n<pre><em>const</em> arr=['said',20,'JavaScript enthusiast','Hi','Said','How are you?'];</pre>\n<pre><em>const</em> Func=(...anArray)<em>=&gt;</em>{<br>return anArray;<br>}<br><em>console</em>.log(Func(arr));<br>//output  [\"said\", 20, \"JavaScript enthusiast\", \"Hi\", \"Said\", \"How are you?\"</pre>\n<h3>Classes</h3>\n<p>Classes are the core of object oriented programming (OOP). They make your code more secure and encapsulated. Using classes gives your code a nice structure and keeps it oriented.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/535/1*ht30N18_fdWnRa5qKsZwvg.png\"></figure><p>To create a class, use the class keyword followed by the name of the class with two curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/914/1*GqEJkUDBPtZ_uxx0hlDMNg.png\"></figure><p>Now we can access the class methods and properties using the newkeyword.</p>\n<pre><em>class</em> myClass{<br><em>constructor</em>(<em>name</em>,<em>age</em>){<br>    this.name=name;<br>    this.age=age;<br>}<br>}<br><em>const</em> Home= new myClass(\"said\",20);</pre>\n<pre><em>console</em>.log(Home.name)//  said</pre>\n<p>To inherit from another class, use the extends keyword followed by the name of the class you want to inheritÂ from.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/937/1*2toiRjEKo_jhig8_WAbAVg.png\"></figure><p>You can learn more about Classes<strong>Â </strong><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Classes\">here</a>.</p>\n<p>ES6 has other amazing featuresâ€Šâ€”â€Šyou can explore themÂ <a href=\"http://es6-features.org/\">here</a>.</p>\n<h3>Conclusion</h3>\n<p>I hope you guys found this article useful, and I hope I was able to introduce you some of the ES6Â features</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1dcb7d40952c\" width=\"1\" height=\"1\">\n",
          "content": "\n<p>JavaScript ES6 brings new syntax and new awesome features to make your code more modern and more readable. It allows you to write less code and do more. ES6 introduces us to many great features like arrow functions, template strings, class destruction, Modulesâ€¦ and more. Letâ€™s take aÂ look.</p>\n<h3>const andÂ let</h3>\n<p>const is a new keyword in ES6 for declaring variables. const is more powerful than var. Once used, the variable canâ€™t be reassigned. In other words, itâ€™s an <strong>immutable variable </strong>except when it used withÂ objects.</p>\n<p>This is really useful for targeting the selectors. For example, when we have a single button that fires an event, or when you want to select an HTML element in JavaScript, use const instead of var. This is because var is â€˜hoistedâ€™. Itâ€™s always preferable to use const when donâ€™t want to reassign the variableÂ .</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/779/1*67201m2bx5fRSzP2lbXLqA.png\"></figure><p>In the code above, const will not change and cannot be reassigned. If you try to give it a new value, it will return you anÂ error.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/561/1*6hP1VNVQ_8Siv6HQyju9cA.png\"></figure><p>let can be reassigned and take new value. It creates a <strong>mutable variable</strong>.</p>\n<p>let is the same as const in that both are blocked-scope. It means that the variable is only available within itsÂ scope.</p>\n<h3>Arrow functions</h3>\n<p>The arrow function is really awesome, and makes your code more readable, more structured, and look like modern code. Instead of usingÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/763/1*fjf4cc0kHb27cRlnSrmwcQ.png\"></figure><p>Use this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*ol3OyEl4zCwGdLT5OOmyRg.png\"></figure><p>As you see, the arrow function seems more readable and clean! You wonâ€™t need to use the old syntaxÂ anymore.</p>\n<p>Also, you can use Arrow function with map, filter, and reduce<strong> </strong>built-in functions.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/943/1*ryJby1pq8wA3EyIp1sRNTQ.png\"></figure><p>The map function with arrows looks more clear and readable than map in ES5. With ES6 you can write shorter and smarter code. You can use the same with filter andÂ reduce.</p>\n<h3>Template Literals</h3>\n<p>Template literals or template strings are pretty cool. We donâ€™t have to use the plus (+) operator to concatenate strings, or when we want to use a variable inside aÂ string.</p>\n<p>The oldÂ syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/925/1*RxqfDIe2jNG4E1KUD3Mw-w.png\"></figure><p>With new ES6Â syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/924/1*16Yxl9wpSuttbJMuFsiNYA.png\"></figure><p>So simple! Itâ€™s a really huge difference between the old syntax and ES6. When playing with strings, the literal string in ES6 looks more organized and well structured thanÂ ES5.</p>\n<h3>Default parameters</h3>\n<p>When I work in PHP, I usually use default parameters. These allow you to define a parameter inÂ advance.</p>\n<p>So, when you forget to write the parameter, it wonâ€™t return an undefined error because the parameter is already defined in the default. So when you run your function with a missed parameter, it will take the value of the default parameter, and it will not return anÂ error!</p>\n<p>Look at thisÂ example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*YWalapv4SCVHEjp32G6SOQ.png\"></figure><p>The function above returns undefined because we forgot to give it the second parameter.</p>\n<p>But if we used the default parameter, it wonâ€™t return undefined, and it will use its value when we forget to assign a parameter!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/907/1*PYEr_IMC1Uu6m4VFETEfRw.png\"></figure><p>As you see, the function returns a value even though we missed the second parameter. Now with the default parameter, we can handle the error inÂ advance.</p>\n<h3>Array and object destructing</h3>\n<p>Destruction makes the assignment of the values of an array or object to the new variableÂ easier.</p>\n<p>The oldÂ syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*-_gztZYidNjUmczN03vHLg.png\"></figure><p>With ES6Â syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/703/1*xBodgoxrytIjNxXU42QTng.png\"></figure><p>With ES5, we have to assign each value to each variable. With ES6, we just put our values within curly brackets to get any property of theÂ object.</p>\n<p>Note:<strong> </strong>if you assign a variable that is not identical to the name of property, it will return undefined. For example, if the name of the property is name and we assign it to a username<strong> </strong>variable,<strong> </strong>it will return undefined.</p>\n<p>We always have to name the variable the same as the name of the property. But in case we want to rename the variable, we can use the colonÂ :Â instead.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*p1IcVKmbO5pVANRn3kATKA.png\"></figure><p>For the array, we use the same syntax as the object. We have just to replace the curly brackets with square brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*zXKJpPbOh-T-0EYDjRS7-g.png\"></figure><h3>Import andÂ export</h3>\n<p>Using import and export in your JavaScript application makes it more powerful. They allow you to create separate and reusable components.</p>\n<p>If you are familiar with any JavaScript MVC framework, you will see that they use import and export to handle the components most of the time. So how do they reallyÂ work?</p>\n<p>It is simple! export allows you to export a module to be used in another JavaScript component. We use import to import that module to use it in our component.</p>\n<p>For example, we have two files. The first is named detailComponent.js<strong> </strong>and the second is named<strong> </strong>homeComponent.js.</p>\n<p>In detailComponent.js<strong> </strong>we are going to export the detail function.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*8d92-RWEx0ygfE22dVWGDA.png\"></figure><p>And if we want to use this function in homeComponent.js,<strong> </strong>we will just useÂ import.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*9BZyWlYn4AYUiJxHjGRSlg.png\"></figure><p>If we want to import more than one module, we just put them within curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VYV52kLrNzZB5-hvartRxA.png\"></figure><p>So cool, isnâ€™tÂ it?!</p>\n<h3>Promises</h3>\n<p>Promises are a new feature of ES6. Itâ€™s a method to write asynchronous code. It can be used when, for example, we want to fetch data from an API, or when we have a function that takes time to be executed. Promises make it easier to solve the problem, so letâ€™s create our firstÂ Promise!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1011/1*RPGNKVoCRxnA-uVv9Kl4mA.png\"></figure><p>If you log your console, it will return a Promise. So, if we want to execute a function after data is fetched, we will use a Promise. The Promise takes two parameters: resolve and reject to handle an expectedÂ error.</p>\n<p>Note: the fetch function returns a PromiseÂ itself!</p>\n<pre><em>const</em> url='https://jsonplaceholder.typicode.com/posts';</pre>\n<pre><em>const</em> getData=(<em>url</em>)<em>=&gt;</em>{<br>return fetch(url);<br>}</pre>\n<pre>getData(url).<br>then(<em>data=&gt;</em> data.json()).<br>then(<em>result=&gt;</em> <em>console</em>.log(result));</pre>\n<p>Now if you log your console it will return an array ofÂ data.</p>\n<h3>Rest parameter and SpreadÂ operator</h3>\n<p><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Functions/rest_parameters\">The rest parameter</a>s are used to get the argument of an array, and return a newÂ array.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/961/1*8ohFXBJT4xFXwAScL5fy_g.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/976/1*v_5auLvegq0LqezITsIJyw.png\"></figure><p>The spread operator has the same syntax as the rest parameter, but the spread operator takes the Array itself and not just the arguments. We can use the Spread parameter to get the values of an Array, instead of using a for loop or any otherÂ method.</p>\n<pre><em>const</em> arr=['said',20,'JavaScript enthusiast','Hi','Said','How are you?'];</pre>\n<pre><em>const</em> Func=(...anArray)<em>=&gt;</em>{<br>return anArray;<br>}<br><em>console</em>.log(Func(arr));<br>//output  [\"said\", 20, \"JavaScript enthusiast\", \"Hi\", \"Said\", \"How are you?\"</pre>\n<h3>Classes</h3>\n<p>Classes are the core of object oriented programming (OOP). They make your code more secure and encapsulated. Using classes gives your code a nice structure and keeps it oriented.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/535/1*ht30N18_fdWnRa5qKsZwvg.png\"></figure><p>To create a class, use the class keyword followed by the name of the class with two curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/914/1*GqEJkUDBPtZ_uxx0hlDMNg.png\"></figure><p>Now we can access the class methods and properties using the newkeyword.</p>\n<pre><em>class</em> myClass{<br><em>constructor</em>(<em>name</em>,<em>age</em>){<br>    this.name=name;<br>    this.age=age;<br>}<br>}<br><em>const</em> Home= new myClass(\"said\",20);</pre>\n<pre><em>console</em>.log(Home.name)//  said</pre>\n<p>To inherit from another class, use the extends keyword followed by the name of the class you want to inheritÂ from.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/937/1*2toiRjEKo_jhig8_WAbAVg.png\"></figure><p>You can learn more about Classes<strong>Â </strong><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Classes\">here</a>.</p>\n<p>ES6 has other amazing featuresâ€Šâ€”â€Šyou can explore themÂ <a href=\"http://es6-features.org/\">here</a>.</p>\n<h3>Conclusion</h3>\n<p>I hope you guys found this article useful, and I hope I was able to introduce you some of the ES6Â features</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1dcb7d40952c\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript"
          ]
      },
      {
          "title": "Node JS Interview Question â€” Set #05",
          "pubDate": "2018-09-13 15:57:50",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-05-3df44d32d3a3?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/3df44d32d3a3",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question â€” Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question â€” Set #03</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-04-b3ea7567675f\">Node JS Interview Question â€” Set #04</a></li>\n</ul>\n<h3>Question 41</h3>\n<p>How to prevent Unhandled Exception in Node JS and if they are occurring how to handleÂ them</p>\n<p>Node.js event loop runs on a single thread and uncaught exceptions are critical issue and need to be aware of when developing applications.</p>\n<p>Silently Handling Exceptions</p>\n<p>Most of the people let node.js server(s) silently swallow up theÂ errors.</p>\n<p>Silently handling the exception</p>\n<pre>process.on(â€˜uncaughtExceptionâ€™, <strong>function</strong> (err) {<br> console.log(err);<br>});</pre>\n<p>This is bad, it will workÂ but:</p>\n<p>In this case Root cause of problem will remains unknown, as such will not contribute to resolution of what caused the Exception (ErrorÂ ).</p>\n<p>In case of node application having database connection ( pool ) which gets closed for some reason will result in constant propagation of errors, meaning that server will be running but it will not reconnect to db. So you should write a code which can manage and do not generate Unhandled exception and for debugging purpose you can caught those process and identify theÂ cause.</p>\n<h3>Question 42</h3>\n<p>How to convert callback based library to promise based library so instead of writing callback we can write promises.</p>\n<p>This is an important aspect and this is being used for many library like redis-client, mysql-client, we can use bluebird.promisifyAll to convert any callback based library to promiseÂ based.</p>\n<pre>db.notification.email.find({subject: â€˜promisify callbackâ€™}, (error, result) =&gt; {<br><strong>if</strong> (error) {<br> console.log(error);<br> }<br> // normal code here<br>});</pre>\n<p>It is using bluebirdâ€™s promisifyAll method to promisify what is conventionally callback-based library.</p>\n<p>After applying these change promise-based methods names wil have Async appended toÂ them:</p>\n<pre><strong>let</strong> email = bluebird.promisifyAll(db.notification.email);<br>email.findAsync({subject: â€˜promisify callbackâ€™}).then(result =&gt; {<br> // normal code here<br>})<br>.catch(console.error);</pre>\n<p>Same thing can be done for redis library which is callback basedÂ library</p>\n<pre><strong>const</strong> redis = require(â€˜redisâ€™);<br>bluebird.promisifyAll(redis);<br>client.getAsync(â€˜data:keyâ€™).then(<strong>function</strong>(res) {<br> console.log(res); // =&gt; â€˜barâ€™<br>});</pre>\n<h3>Question 43</h3>\n<p>What is global object in Node JS how to add object to global variable &amp; how itâ€™s different from browser global environment.</p>\n<p>In browsers when we do console.log(this) it represent the window object and in node JS the global scope of a module is the module itself, so when you define a variable in the global scope of your node JS module, it will be local to thisÂ module.</p>\n<p>In node js global represents global scope only you can add variable in global object it will be available on node js process and can be accessed in any other localÂ module.</p>\n<p>We can add some common configuration to global object like mysql connection object or logger object as we will using these objects on different places in application.</p>\n<pre><strong>const</strong> mysql = require(â€˜mysql2â€™);<br>global.connection = <strong>null</strong>;<br><strong>try</strong> {<br> global.connection = mysql.createConnection(global.configuration.db);<br>} <strong>catch</strong> (err) {<br><strong>throw</strong> Error(err);<br>}<br>global.connection.connect((err) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br>});<br>global.connection.on(â€˜errorâ€™, (err) =&gt; {<br> logger.info(`Cannot establish a connection with the database (${err.code})`);<br>});<br>module.exports = global.connection;</pre>\n<p>global&lt;Object&gt; The global namespace object.</p>\n<p>In browsers, the top-level scope is the global scope. That means that in browsers if youâ€™re in the global scope var something will define a global variable. In Node.js this is different. The top-level scope is not the global scope; var something inside an Node.js module will be local to thatÂ module.</p>\n<h3>Question 44</h3>\n<p>What is circular dependency in modules while executing Node JS and how to fix thisÂ issue</p>\n<p>In this example there two file which are doing require each other foo file one is requiring file and same thing is happening withÂ bar.js</p>\n<p>Itâ€™s like circular dependency &amp; these is no issue it will compile as expected but at run time behaviour is totally different then expected.</p>\n<p>foo is being imported in bar module &amp; bar is being imported in fooÂ module</p>\n<p>The important part is it is being done synchronously,no module.export calls have yet been made!. So when bar.js was required intofoo.js, it immediately tried to require bar.js back into itself, but foo.js hasnâ€™t been exported yet. The result is that foo.js only has a reference to an emptyÂ object!</p>\n<p>This is called circular dependency and you should import export modules not in circularÂ way.</p>\n<p><a href=\"https://www.npmjs.com/package/madge\">https://www.npmjs.com/package/madge</a> can be used to detect such kind of circular dependencies</p>\n<pre>// hello.js<br><strong>var</strong> bar = require(â€˜./foo.jsâ€™); <br>console.log(â€˜class b:â€™, bar);<br><strong>var</strong> foo = <strong>function</strong>() { <br><strong>this</strong>.bInstance = bar();<br><strong>this</strong>.property = 5;<br>}<br>module.exports = foo;</pre>\n<pre>// hello1.js<br><strong>var</strong> foo = require(â€˜./foo.jsâ€™);<br><strong>var</strong> bar = <strong>function</strong>() {}<br>bar.prototype.doSomethingLater = <strong>function</strong>() { <br> console.log(foo.property);<br>}<br>module.exports = bar;</pre>\n<h3>Question 45</h3>\n<p>What is the Node JS require cache and how to invalidate it</p>\n<p>when we require module in one file it gets cached in node js and its gets passed to another module requiring same module again this is require cache which node js maintain in node js execution cycle. It can also be invalidated whenÂ needed</p>\n<p>and Yes, you can access the cache via require.cache[moduleName] where moduleName is the name of the module you wish to access. Deleting an entry by calling delete require.cache[moduleName] will cause require to load the actualÂ file.</p>\n<p>So from the above description we can say yes, you can invalidate cache.</p>\n<p>The cache is stored in object require.cache which you can access according to filenames (e.g.â€Šâ€”â€Š~/home/index.js as opposed toÂ ./home which you would use in a require(â€˜./homeâ€™) statement).</p>\n<h3>Question 46</h3>\n<p>What is the best way to add security to apis in Node JS application, what are some well known module should can beÂ used.</p>\n<p>For security we should take care of lot of things but here letâ€™s see how we can make apis moreÂ secure</p>\n<ul>\n<li>Donâ€™t use deprecated or vulnerable versions ofÂ Express</li>\n<li>Use latest version of NPM &amp; run ( npm auditÂ )</li>\n<li>Use Helmet, csurf module for addingÂ security</li>\n<li>Add security to the cookies by signing cookies or making themÂ secure.</li>\n<li>Add rate limiter to prevent brute forceÂ attack</li>\n<li>Send Security HTTPÂ Headers</li>\n<li>Prevent SQL injection in yourÂ code.</li>\n<li>APIs should be running onÂ HTTPS</li>\n<li>run npm audit regularly</li>\n</ul>\n<p><strong>Secure Express.js Sessions andÂ Cookies</strong></p>\n<p>Session cookie name reveals your applicationâ€™s internals</p>\n<p>Revealing what technologies you are using for your application is one of the key things that you should not do. If an attacker knows what kind of technology you are using, he can drastically reduce his scope in finding vulnerable components in your application. There are a couple of ways which reveals internal implementation details of your application. One of them is the session cookie name of your application.</p>\n<p><strong>Make cookies moreÂ secure</strong></p>\n<p>When you use cookies in your application make sure to add HttpOnly flag to the cookies. Adding HttpOnly flag makes sure that no external script other than an HTTP connection can fetch cookies in your application. This is a good protection mechanism against cross site scripting attacks where attackers read your cookies through malicious scripts.</p>\n<p><strong>Signing cookies</strong></p>\n<p>Signing cookies provide prevention of cookie forging. A signed cookie is a value which has the cookie value as well as a digital signature attached to itself. Once the cookie is received from the server end, the server will validate the integrity of the cookie by validating its signature</p>\n<p><a href=\"https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971\">https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971</a></p>\n<pre>app.disable(â€˜x-powered-byâ€™);<br> app.use(helmet());<br> app.use(helmet.noCache({ noEtag: <strong>true</strong> })); // set Cache-Control header<br> app.use(helmet.noSniff()); // set X-Content-Type-Options header<br> app.use(helmet.frameguard()); // set X-Frame-Options header<br> app.use(helmet.xssFilter()); // set X-XSS-Protection header<br> app.enable(â€˜trust proxyâ€™, [â€˜loopbackâ€™, â€˜linklocalâ€™, â€˜uniquelocalâ€™]);<br> app.use(expressSession({<br> name: â€˜SESS_IDâ€™,<br> secret: configServer.SESSION_SECRET,<br> proxy: <strong>true</strong>,<br> resave: <strong>true</strong>,<br> saveUninitialized: <strong>true</strong>,<br> }));</pre>\n<h3>Question 47</h3>\n<p>How error handling can be done in Node JS api app like handling apiÂ errors.</p>\n<p>Error handling is a feature of express which can be done by using some middleware. Error can be some defined errors codes or some errors are runtime errors coming from database, redis or some other dataÂ store.</p>\n<p>Server ErrorsÂ : There are many error codes which are returned from API like 301,404,403 orÂ 500.</p>\n<p>API Error CodesÂ : In APIs we can return error codes with our own message to notify client about situation at server side like â€œuser data not foundâ€, These are some known errors which we are throwing explicitly from code but what should we do with runtime errors like some database connection issue, some column is missing or query is not correctly written.</p>\n<pre>router.get(â€˜/users/:idâ€™, <strong>function</strong>(req, res, next) {<br><strong>var</strong> user = users.getUserById(req.params.id);<br><strong>if</strong> (user == <strong>null</strong> || user == â€˜undefinedâ€™) { <br> res.status(400).json({â€˜messageâ€™ : â€˜user not foundâ€™});<br> }<br>});</pre>\n<p>For handling such unknown runtime errors we can just create middleware and this middleware will have error object additional which will give us detail about what error occured with stack trace &amp; statusÂ code.</p>\n<p>Create error handler middleware as global Middleware and register this middleware with app instance.</p>\n<pre><strong>class</strong> <strong>errorHandlers</strong> {<br><strong>static</strong> internalServerError(err, req, res, next) {<br> res.status(500).json({<br> success: <strong>false</strong>,<br> message: err.message,<br> error: err.stack ,<br> }); <br> }<br>}<br>module.exports = errorHandlers;<br>// in your server.js<br>app.use(errorHandlers.internalServerError);</pre>\n<h3>Question 48</h3>\n<p>How to create basic middleware and how to register middleware in application.</p>\n<p>Middleware functions are simple javascript functions that have access to the request response object and the next function during application request response cycle. In middleware we do pre and post processing with request and responseÂ object.</p>\n<p>We can talk about basic example of pre processing requestsÂ like</p>\n<ol>\n<li>HTTP post method should not have empty body an example of pre processing ofÂ request</li>\n<li>HTTP Methods should have application/json as contentÂ type.</li>\n<li>Secured routes should have some token available in request for checking authorisation. This can be done using some middleware which will check request for protected routes and validate if available token in request isÂ valid.</li>\n</ol>\n<p>Middleware function should call next function to execute or move to next middleware.</p>\n<p>Middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function otherwise, the request will be left stuck or hanging inÂ middle.</p>\n<p>we use middleware to do pre processing and post processing for request processing.</p>\n<p>We can have simple example of Express application. We create an express application which is sending response â€œhello worldâ€ on â€œ/â€ route request and serving on HTTP PortÂ 3000.</p>\n<pre><strong>var</strong> express = require(â€˜expressâ€™)<br><strong>var</strong> app = express()</pre>\n<pre>app.get(â€˜/â€™, <strong>function</strong> (req, res) {<br> res.send(â€˜Hello World!â€™)<br>})</pre>\n<pre><strong>app.listen(3000)</strong></pre>\n<p><strong>Middleware function loggerÂ example</strong></p>\n<p>Here is a simple example of a middleware function called â€œloggerâ€. This function will be logging message â€˜LOGGEDâ€™ on each and every request as we have registered this middleware on app instance by doing app.use(middleware).</p>\n<pre><strong>var</strong> myLogger = <strong>function</strong> (req, res, next) {<br> console.log(â€˜LOGGEDâ€™)<br> next()<br>}<br>// this is how we register middleware<br>app.use(myLogger)</pre>\n<p>We can add middleware to a route itself instead of doing it on express instance and making that middleware global for each and every request, in this case this middleware will be available for this routeÂ only.</p>\n<p>We do have global middleware which we register on app instance like body parser which is used to extract req body from coming request fromÂ client.</p>\n<pre>// parse application/x-www-form-urlencoded<br>app.use(bodyParser.urlencoded({ extended: <strong>false</strong> })</pre>\n<pre>// parse application/json<br>app.use(bodyParser.json())</pre>\n<pre>Example of middleware registered only to a route.</pre>\n<pre><strong>var</strong> middleware = <strong>function</strong>(req,res,next){<br> next()<br>}<br>app.get(â€˜/â€™, middleware, <strong>function</strong> (req, res) {<br> res.send(â€˜Hello World!â€™)<br>})</pre>\n<h3>Question 49</h3>\n<p>Can you explain how logging can be done in Node JS application api logging or simple logging in someÂ file</p>\n<p>logging is important aspect of node js programming, There are different modules available in node js to add logging in node js application</p>\n<p>Logging is needed in Node.js to capture bugs during application runtime.</p>\n<p>logging is needed because we want toÂ :</p>\n<ol>\n<li>To have a better understanding of how your applications works,</li>\n<li>To discover what errors you may encounter runtime.</li>\n<li>To find out if your services are running properly without unhandled errors.</li>\n</ol>\n<p>winston is important module which you can have for logging purpose. Winston is a multi-transport async logging library for Node.js. When i say multi transport means i can have different medium to manage myÂ logs.</p>\n<ol>\n<li>Storing logs on files with custom logÂ format.</li>\n<li>Pushing logs onÂ console.</li>\n<li>Sending logs to any another TCPÂ channel.</li>\n<li>Winston has different log levels and different format can be specified forÂ logging</li>\n</ol>\n<p>You can add winston to your project by installing it:</p>\n<p><strong>npm install winstonâ€Šâ€”â€Šsave</strong></p>\n<p>Once you have it, you can add winston to your project thisÂ way:</p>\n<pre>const winston = require(â€˜winstonâ€™);<br>const logger = new winston.Logger({<br> transports: [<br> new winston.transports.File(options.file),<br> new winston<br> .transports<br> .Console({}),<br> ],<br> exceptionHandlers: [<br> // new winston.transports.File(options.errorLog)<br> ],<br> exitOnError: false, // do not exit on handled exceptions<br>});</pre>\n<pre>// create a stream object with a â€˜writeâ€™ function that will be used by `morgan`<br>logger.stream = {<br> write(message, encoding) {<br> logger.info(message);<br> }<br>};<br>module.exports = logger;</pre>\n<h3>Question 50</h3>\n<p>How to monitor Node JS process and api transactions by using any tool or libraryÂ ?</p>\n<p>There are many tools available which can provide real time transaction monitoring and logging of apis like keymatrics and newrelic tools which gives you in detail knowledge about node js process status like memory consumption and timeÂ taken.</p>\n<p>These tools are also being used for performance monitoring ofÂ APIs</p>\n<p>Newrelic &amp; keymatrics are industry standards and being used in many enterprises to check and monitor Node jsÂ process</p>\n<p><a href=\"https://rpm.newrelic.com/\">https://rpm.newrelic.com</a></p>\n<p><a href=\"http://pm2.io/\">http://pm2.io/</a></p>\n<p>Tools for Node js process Monitoring</p>\n<ol>\n<li>appdynamics</li>\n<li>nodemon, forever modules to run process in background without monitoring.</li>\n<li>newRelic gives detailed monitoring statics.</li>\n<li>keymetrics is PM2 based tool which shows statics of individual instance and make application highly available. PM2 gives advantages of having multiple instances of application on system so we can use multi-core system efficiently.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OhKB8whwauyV8y6J\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3df44d32d3a3\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question â€” Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question â€” Set #03</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-04-b3ea7567675f\">Node JS Interview Question â€” Set #04</a></li>\n</ul>\n<h3>Question 41</h3>\n<p>How to prevent Unhandled Exception in Node JS and if they are occurring how to handleÂ them</p>\n<p>Node.js event loop runs on a single thread and uncaught exceptions are critical issue and need to be aware of when developing applications.</p>\n<p>Silently Handling Exceptions</p>\n<p>Most of the people let node.js server(s) silently swallow up theÂ errors.</p>\n<p>Silently handling the exception</p>\n<pre>process.on(â€˜uncaughtExceptionâ€™, <strong>function</strong> (err) {<br> console.log(err);<br>});</pre>\n<p>This is bad, it will workÂ but:</p>\n<p>In this case Root cause of problem will remains unknown, as such will not contribute to resolution of what caused the Exception (ErrorÂ ).</p>\n<p>In case of node application having database connection ( pool ) which gets closed for some reason will result in constant propagation of errors, meaning that server will be running but it will not reconnect to db. So you should write a code which can manage and do not generate Unhandled exception and for debugging purpose you can caught those process and identify theÂ cause.</p>\n<h3>Question 42</h3>\n<p>How to convert callback based library to promise based library so instead of writing callback we can write promises.</p>\n<p>This is an important aspect and this is being used for many library like redis-client, mysql-client, we can use bluebird.promisifyAll to convert any callback based library to promiseÂ based.</p>\n<pre>db.notification.email.find({subject: â€˜promisify callbackâ€™}, (error, result) =&gt; {<br><strong>if</strong> (error) {<br> console.log(error);<br> }<br> // normal code here<br>});</pre>\n<p>It is using bluebirdâ€™s promisifyAll method to promisify what is conventionally callback-based library.</p>\n<p>After applying these change promise-based methods names wil have Async appended toÂ them:</p>\n<pre><strong>let</strong> email = bluebird.promisifyAll(db.notification.email);<br>email.findAsync({subject: â€˜promisify callbackâ€™}).then(result =&gt; {<br> // normal code here<br>})<br>.catch(console.error);</pre>\n<p>Same thing can be done for redis library which is callback basedÂ library</p>\n<pre><strong>const</strong> redis = require(â€˜redisâ€™);<br>bluebird.promisifyAll(redis);<br>client.getAsync(â€˜data:keyâ€™).then(<strong>function</strong>(res) {<br> console.log(res); // =&gt; â€˜barâ€™<br>});</pre>\n<h3>Question 43</h3>\n<p>What is global object in Node JS how to add object to global variable &amp; how itâ€™s different from browser global environment.</p>\n<p>In browsers when we do console.log(this) it represent the window object and in node JS the global scope of a module is the module itself, so when you define a variable in the global scope of your node JS module, it will be local to thisÂ module.</p>\n<p>In node js global represents global scope only you can add variable in global object it will be available on node js process and can be accessed in any other localÂ module.</p>\n<p>We can add some common configuration to global object like mysql connection object or logger object as we will using these objects on different places in application.</p>\n<pre><strong>const</strong> mysql = require(â€˜mysql2â€™);<br>global.connection = <strong>null</strong>;<br><strong>try</strong> {<br> global.connection = mysql.createConnection(global.configuration.db);<br>} <strong>catch</strong> (err) {<br><strong>throw</strong> Error(err);<br>}<br>global.connection.connect((err) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br>});<br>global.connection.on(â€˜errorâ€™, (err) =&gt; {<br> logger.info(`Cannot establish a connection with the database (${err.code})`);<br>});<br>module.exports = global.connection;</pre>\n<p>global&lt;Object&gt; The global namespace object.</p>\n<p>In browsers, the top-level scope is the global scope. That means that in browsers if youâ€™re in the global scope var something will define a global variable. In Node.js this is different. The top-level scope is not the global scope; var something inside an Node.js module will be local to thatÂ module.</p>\n<h3>Question 44</h3>\n<p>What is circular dependency in modules while executing Node JS and how to fix thisÂ issue</p>\n<p>In this example there two file which are doing require each other foo file one is requiring file and same thing is happening withÂ bar.js</p>\n<p>Itâ€™s like circular dependency &amp; these is no issue it will compile as expected but at run time behaviour is totally different then expected.</p>\n<p>foo is being imported in bar module &amp; bar is being imported in fooÂ module</p>\n<p>The important part is it is being done synchronously,no module.export calls have yet been made!. So when bar.js was required intofoo.js, it immediately tried to require bar.js back into itself, but foo.js hasnâ€™t been exported yet. The result is that foo.js only has a reference to an emptyÂ object!</p>\n<p>This is called circular dependency and you should import export modules not in circularÂ way.</p>\n<p><a href=\"https://www.npmjs.com/package/madge\">https://www.npmjs.com/package/madge</a> can be used to detect such kind of circular dependencies</p>\n<pre>// hello.js<br><strong>var</strong> bar = require(â€˜./foo.jsâ€™); <br>console.log(â€˜class b:â€™, bar);<br><strong>var</strong> foo = <strong>function</strong>() { <br><strong>this</strong>.bInstance = bar();<br><strong>this</strong>.property = 5;<br>}<br>module.exports = foo;</pre>\n<pre>// hello1.js<br><strong>var</strong> foo = require(â€˜./foo.jsâ€™);<br><strong>var</strong> bar = <strong>function</strong>() {}<br>bar.prototype.doSomethingLater = <strong>function</strong>() { <br> console.log(foo.property);<br>}<br>module.exports = bar;</pre>\n<h3>Question 45</h3>\n<p>What is the Node JS require cache and how to invalidate it</p>\n<p>when we require module in one file it gets cached in node js and its gets passed to another module requiring same module again this is require cache which node js maintain in node js execution cycle. It can also be invalidated whenÂ needed</p>\n<p>and Yes, you can access the cache via require.cache[moduleName] where moduleName is the name of the module you wish to access. Deleting an entry by calling delete require.cache[moduleName] will cause require to load the actualÂ file.</p>\n<p>So from the above description we can say yes, you can invalidate cache.</p>\n<p>The cache is stored in object require.cache which you can access according to filenames (e.g.â€Šâ€”â€Š~/home/index.js as opposed toÂ ./home which you would use in a require(â€˜./homeâ€™) statement).</p>\n<h3>Question 46</h3>\n<p>What is the best way to add security to apis in Node JS application, what are some well known module should can beÂ used.</p>\n<p>For security we should take care of lot of things but here letâ€™s see how we can make apis moreÂ secure</p>\n<ul>\n<li>Donâ€™t use deprecated or vulnerable versions ofÂ Express</li>\n<li>Use latest version of NPM &amp; run ( npm auditÂ )</li>\n<li>Use Helmet, csurf module for addingÂ security</li>\n<li>Add security to the cookies by signing cookies or making themÂ secure.</li>\n<li>Add rate limiter to prevent brute forceÂ attack</li>\n<li>Send Security HTTPÂ Headers</li>\n<li>Prevent SQL injection in yourÂ code.</li>\n<li>APIs should be running onÂ HTTPS</li>\n<li>run npm audit regularly</li>\n</ul>\n<p><strong>Secure Express.js Sessions andÂ Cookies</strong></p>\n<p>Session cookie name reveals your applicationâ€™s internals</p>\n<p>Revealing what technologies you are using for your application is one of the key things that you should not do. If an attacker knows what kind of technology you are using, he can drastically reduce his scope in finding vulnerable components in your application. There are a couple of ways which reveals internal implementation details of your application. One of them is the session cookie name of your application.</p>\n<p><strong>Make cookies moreÂ secure</strong></p>\n<p>When you use cookies in your application make sure to add HttpOnly flag to the cookies. Adding HttpOnly flag makes sure that no external script other than an HTTP connection can fetch cookies in your application. This is a good protection mechanism against cross site scripting attacks where attackers read your cookies through malicious scripts.</p>\n<p><strong>Signing cookies</strong></p>\n<p>Signing cookies provide prevention of cookie forging. A signed cookie is a value which has the cookie value as well as a digital signature attached to itself. Once the cookie is received from the server end, the server will validate the integrity of the cookie by validating its signature</p>\n<p><a href=\"https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971\">https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971</a></p>\n<pre>app.disable(â€˜x-powered-byâ€™);<br> app.use(helmet());<br> app.use(helmet.noCache({ noEtag: <strong>true</strong> })); // set Cache-Control header<br> app.use(helmet.noSniff()); // set X-Content-Type-Options header<br> app.use(helmet.frameguard()); // set X-Frame-Options header<br> app.use(helmet.xssFilter()); // set X-XSS-Protection header<br> app.enable(â€˜trust proxyâ€™, [â€˜loopbackâ€™, â€˜linklocalâ€™, â€˜uniquelocalâ€™]);<br> app.use(expressSession({<br> name: â€˜SESS_IDâ€™,<br> secret: configServer.SESSION_SECRET,<br> proxy: <strong>true</strong>,<br> resave: <strong>true</strong>,<br> saveUninitialized: <strong>true</strong>,<br> }));</pre>\n<h3>Question 47</h3>\n<p>How error handling can be done in Node JS api app like handling apiÂ errors.</p>\n<p>Error handling is a feature of express which can be done by using some middleware. Error can be some defined errors codes or some errors are runtime errors coming from database, redis or some other dataÂ store.</p>\n<p>Server ErrorsÂ : There are many error codes which are returned from API like 301,404,403 orÂ 500.</p>\n<p>API Error CodesÂ : In APIs we can return error codes with our own message to notify client about situation at server side like â€œuser data not foundâ€, These are some known errors which we are throwing explicitly from code but what should we do with runtime errors like some database connection issue, some column is missing or query is not correctly written.</p>\n<pre>router.get(â€˜/users/:idâ€™, <strong>function</strong>(req, res, next) {<br><strong>var</strong> user = users.getUserById(req.params.id);<br><strong>if</strong> (user == <strong>null</strong> || user == â€˜undefinedâ€™) { <br> res.status(400).json({â€˜messageâ€™ : â€˜user not foundâ€™});<br> }<br>});</pre>\n<p>For handling such unknown runtime errors we can just create middleware and this middleware will have error object additional which will give us detail about what error occured with stack trace &amp; statusÂ code.</p>\n<p>Create error handler middleware as global Middleware and register this middleware with app instance.</p>\n<pre><strong>class</strong> <strong>errorHandlers</strong> {<br><strong>static</strong> internalServerError(err, req, res, next) {<br> res.status(500).json({<br> success: <strong>false</strong>,<br> message: err.message,<br> error: err.stack ,<br> }); <br> }<br>}<br>module.exports = errorHandlers;<br>// in your server.js<br>app.use(errorHandlers.internalServerError);</pre>\n<h3>Question 48</h3>\n<p>How to create basic middleware and how to register middleware in application.</p>\n<p>Middleware functions are simple javascript functions that have access to the request response object and the next function during application request response cycle. In middleware we do pre and post processing with request and responseÂ object.</p>\n<p>We can talk about basic example of pre processing requestsÂ like</p>\n<ol>\n<li>HTTP post method should not have empty body an example of pre processing ofÂ request</li>\n<li>HTTP Methods should have application/json as contentÂ type.</li>\n<li>Secured routes should have some token available in request for checking authorisation. This can be done using some middleware which will check request for protected routes and validate if available token in request isÂ valid.</li>\n</ol>\n<p>Middleware function should call next function to execute or move to next middleware.</p>\n<p>Middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function otherwise, the request will be left stuck or hanging inÂ middle.</p>\n<p>we use middleware to do pre processing and post processing for request processing.</p>\n<p>We can have simple example of Express application. We create an express application which is sending response â€œhello worldâ€ on â€œ/â€ route request and serving on HTTP PortÂ 3000.</p>\n<pre><strong>var</strong> express = require(â€˜expressâ€™)<br><strong>var</strong> app = express()</pre>\n<pre>app.get(â€˜/â€™, <strong>function</strong> (req, res) {<br> res.send(â€˜Hello World!â€™)<br>})</pre>\n<pre><strong>app.listen(3000)</strong></pre>\n<p><strong>Middleware function loggerÂ example</strong></p>\n<p>Here is a simple example of a middleware function called â€œloggerâ€. This function will be logging message â€˜LOGGEDâ€™ on each and every request as we have registered this middleware on app instance by doing app.use(middleware).</p>\n<pre><strong>var</strong> myLogger = <strong>function</strong> (req, res, next) {<br> console.log(â€˜LOGGEDâ€™)<br> next()<br>}<br>// this is how we register middleware<br>app.use(myLogger)</pre>\n<p>We can add middleware to a route itself instead of doing it on express instance and making that middleware global for each and every request, in this case this middleware will be available for this routeÂ only.</p>\n<p>We do have global middleware which we register on app instance like body parser which is used to extract req body from coming request fromÂ client.</p>\n<pre>// parse application/x-www-form-urlencoded<br>app.use(bodyParser.urlencoded({ extended: <strong>false</strong> })</pre>\n<pre>// parse application/json<br>app.use(bodyParser.json())</pre>\n<pre>Example of middleware registered only to a route.</pre>\n<pre><strong>var</strong> middleware = <strong>function</strong>(req,res,next){<br> next()<br>}<br>app.get(â€˜/â€™, middleware, <strong>function</strong> (req, res) {<br> res.send(â€˜Hello World!â€™)<br>})</pre>\n<h3>Question 49</h3>\n<p>Can you explain how logging can be done in Node JS application api logging or simple logging in someÂ file</p>\n<p>logging is important aspect of node js programming, There are different modules available in node js to add logging in node js application</p>\n<p>Logging is needed in Node.js to capture bugs during application runtime.</p>\n<p>logging is needed because we want toÂ :</p>\n<ol>\n<li>To have a better understanding of how your applications works,</li>\n<li>To discover what errors you may encounter runtime.</li>\n<li>To find out if your services are running properly without unhandled errors.</li>\n</ol>\n<p>winston is important module which you can have for logging purpose. Winston is a multi-transport async logging library for Node.js. When i say multi transport means i can have different medium to manage myÂ logs.</p>\n<ol>\n<li>Storing logs on files with custom logÂ format.</li>\n<li>Pushing logs onÂ console.</li>\n<li>Sending logs to any another TCPÂ channel.</li>\n<li>Winston has different log levels and different format can be specified forÂ logging</li>\n</ol>\n<p>You can add winston to your project by installing it:</p>\n<p><strong>npm install winstonâ€Šâ€”â€Šsave</strong></p>\n<p>Once you have it, you can add winston to your project thisÂ way:</p>\n<pre>const winston = require(â€˜winstonâ€™);<br>const logger = new winston.Logger({<br> transports: [<br> new winston.transports.File(options.file),<br> new winston<br> .transports<br> .Console({}),<br> ],<br> exceptionHandlers: [<br> // new winston.transports.File(options.errorLog)<br> ],<br> exitOnError: false, // do not exit on handled exceptions<br>});</pre>\n<pre>// create a stream object with a â€˜writeâ€™ function that will be used by `morgan`<br>logger.stream = {<br> write(message, encoding) {<br> logger.info(message);<br> }<br>};<br>module.exports = logger;</pre>\n<h3>Question 50</h3>\n<p>How to monitor Node JS process and api transactions by using any tool or libraryÂ ?</p>\n<p>There are many tools available which can provide real time transaction monitoring and logging of apis like keymatrics and newrelic tools which gives you in detail knowledge about node js process status like memory consumption and timeÂ taken.</p>\n<p>These tools are also being used for performance monitoring ofÂ APIs</p>\n<p>Newrelic &amp; keymatrics are industry standards and being used in many enterprises to check and monitor Node jsÂ process</p>\n<p><a href=\"https://rpm.newrelic.com/\">https://rpm.newrelic.com</a></p>\n<p><a href=\"http://pm2.io/\">http://pm2.io/</a></p>\n<p>Tools for Node js process Monitoring</p>\n<ol>\n<li>appdynamics</li>\n<li>nodemon, forever modules to run process in background without monitoring.</li>\n<li>newRelic gives detailed monitoring statics.</li>\n<li>keymetrics is PM2 based tool which shows statics of individual instance and make application highly available. PM2 gives advantages of having multiple instances of application on system so we can use multi-core system efficiently.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OhKB8whwauyV8y6J\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3df44d32d3a3\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript",
              "nodejs",
              "interview",
              "questions"
          ]
      },
      {
          "title": "Node JS Interview Question â€” Set #04",
          "pubDate": "2018-09-13 15:45:53",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-04-b3ea7567675f?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/b3ea7567675f",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question â€” Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question â€” Set #03</a></li>\n</ul>\n<h3>Question 31</h3>\n<p>Have you used yarn as package manager and how its different fromÂ NPM</p>\n<p>Yarn is just another package manager for installing and managing javascript libraries for application. Yarn is using the same registry that npm does. That means that every package that is a available on npm is the same onÂ Yarn.</p>\n<p>To add a package, run yarn add &lt;package-name&gt;.</p>\n<p>If you need a specific version of the package, you can use yarn add package@version</p>\n<p>yarn also have initÂ command</p>\n<p>The yarn init command will walk you through the creation of a package.json file to configure some information about your package. This is same as we do npm init using npm packageÂ manager</p>\n<p>these are following differences we canÂ see</p>\n<p>Yarn has a few differences from npm. Yarn is doing caching of all installed packages. Yarn is installing the packages simultaneously and when we install packages with Yarn it look like faster than NPM. Both yarn and NPM downloading packages from same NPM repository.</p>\n<p>On the contrary to npm, Yarn provides stability, putting lock on versions of installed packages. The speed is higher while installing packages. It is very important for big projects, which have more dependencies</p>\n<h3>Question 32</h3>\n<p>What are the tools to deploy node js application onÂ server.</p>\n<p>There are many popular tool to deploy node js app on server which will keep node js application up and running and if there is any issue it will restart process like PM2, forever, supervisord</p>\n<p>PM2 providesÂ :</p>\n<ol>\n<li>Built in loadÂ balancer</li>\n<li>Multiple instance of application running on sameÂ port.</li>\n<li>Can run application in clusterÂ mode.</li>\n<li>Can manage deployment of multiple application using singleÂ config.</li>\n<li>Provides multiple deployment options.</li>\n<li>Provides zero downtime on application deployment.</li>\n</ol>\n<p>If you use pm2, you can easily hook it with keymetrics.io monitoring tool to see apiÂ statics.</p>\n<p>npm install -g pm2<br>pm2 startÂ app.js</p>\n<p>Zero-config Load-Balancer Link</p>\n<p>PM2 enable use to create multiple instance to scale up your application by creating instances that share the same server port. Doing this also allow you to restart your app with zero-seconds downtimes.</p>\n<p>PM commands to start/stop/delete application instance</p>\n<p><strong>pm2 start</strong> app.jsâ€Šâ€”â€ŠnameÂ â€œmy-apiâ€</p>\n<p><strong>pm2 start</strong> web.jsâ€Šâ€”â€Šname â€œweb-interfaceâ€</p>\n<p><strong>pm2</strong> stop web-interface.Â â€¦</p>\n<p><strong>pm2</strong> restart web-interface.Â â€¦</p>\n<p><strong>pm2</strong> delete web-interface.Â â€¦</p>\n<p><strong>pm2</strong> restart /http-[1,2]/Â â€¦</p>\n<p><strong>pm2</strong> list # Or <strong>pm2</strong> [list|ls|l|status]</p>\n<p>pm2 list command showing all available instances and pm2 monit command showing monitoring for all running instances</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pzO-erzJeIVNZLnO\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*R4av-BTK2E76Pb8Q\"></figure><p>PM2 has lot of advantages over other tools it gives you everything and its is industry standard for node js deployments.</p>\n<h3>Question 33</h3>\n<p>How to graceful shutdown your Node JS process when something bad happens in code like database connection lost.</p>\n<p>graceful shutdown means whenever node js process shut down in that case we need to shut process down gracefully by closing all db connection by releasing TCP port and releasing all occupied resources so when node process comes up again there should be no anyÂ issues</p>\n<p>graceful shot down can be done in different way</p>\n<p>Shutdown can happen using some code issue like unhandled promise rejection, some javascript code null check missing or database shutdown or forcefully by user using Ctrl +Â C</p>\n<pre>process.on(â€˜unhandledRejectionâ€™, ErrorHandler.unhandledRejection);<br>process.on(â€˜SIGINTâ€™, ErrorHandler.shutdown);<br>process.on(â€˜uncaughtExceptionâ€™, ErrorHandler.onError);</pre>\n<pre>process<br> .on(â€˜unhandledRejectionâ€™, (reason, p) =&gt; {<br> console.error(reason, â€˜Unhandled Rejection at Promiseâ€™, p);<br> // release database connection <br> // release resources<br> });</pre>\n<h3>Question 34</h3>\n<p><strong>How can you make sure of zero downtime while Node JS deployment of your application</strong></p>\n<p>zero downtime means whenever we deploy node js application it stop the application and then start it again in this case there is a downtime of some seconds until application gets connected to database like redis, mysql. Zero downtime canâ€™t be achieved with single instance when we have huge traffic coming forÂ APIs.</p>\n<p>PM2 is powerful tool to manage multiple instances running multiple core of one machine. On multi core system we should always have multiple instance of PM2 to optimally consume multiple cores ofÂ system.</p>\n<ol><li>For having zero downtime we should run application in cluster mode which allows networked Node.js applications (http(s)/tcp/udp server) to be scaled across all CPUs available, without any code modifications. This greatly increases the performance and reliability of your applications, depending on the number of CPUs available</li></ol>\n<p>To enable the cluster mode, just pass the -iÂ option:</p>\n<p>pm2 start app.js -i max <strong>( max means that PM2 will auto detect the number of available CPUs and run as many processes as possible)</strong></p>\n<p>For zero downtime we should use pm2 reload not restart command, reload is different from restart as it will start reloading one by one and not doing reload on all instance together. <strong>pm2 restart app-name</strong>Â ,which kills and restarts the process. <strong>pm2 reload app-name</strong> which restart your workers one by one, and for each worker, wait till the new one has spawned before killing the old one. Using this reload we can serve request by live workers without having any issue in api-services.</p>\n<p>This below mentioned configuration â€œ<strong>ecosystem.config.js</strong>â€ will create max number of instances based on available core on system and run all instances in clusterÂ mode.</p>\n<p><strong>pm2</strong> <strong>startOrReload</strong> ecosystem.config.jsâ€Š<strong>â€”â€Šupdate-env</strong></p>\n<p>This command will start max number of instance if they have not been created yet or reload the existing created instances.â€Šâ€”â€Šupdate-env parameter will reload instance with some newly added configuration.</p>\n<pre>Ecosystem.config.js file:</pre>\n<pre>module.exports = {<br> apps: [<br> {<br> name: â€˜api_appâ€™,<br> script: â€˜app/server.jsâ€™,<br> instances: â€œmaxâ€<br> }<br> ]<br>};</pre>\n<h3>Question 35</h3>\n<p>What is the use of cluster module and how to useÂ it.</p>\n<p>cluster module provide a way to create child process. In some cases we may need to have a child process for running some independent process and want to distribute some process. For that purpose we can use Cluster module which will create another child process and that process is created using like forking aÂ process.</p>\n<p>The cluster module is core node js module like fs,net module. Cluster module contains a set of functions and properties that help us forking processes to take advantage of multi-core systems. Node js runs on single core system but when we have multi core system and in that case to use that multi core system we should create child process which are equal to number of processor inÂ system</p>\n<pre><strong>const</strong> cluster = require(â€˜clusterâ€™);<br><strong>const</strong> http = require(â€˜httpâ€™);<br><strong>const</strong> numCPUs = require(â€˜osâ€™).cpus().length;<br><strong>if</strong> (cluster.isMaster) {<br> masterProcess();<br>} <strong>else</strong> {<br> childProcess(); <br>}<br><strong>function</strong> <strong>masterProcess</strong>() {<br> console.log(`Master ${process.pid} is running`);<br><strong>for</strong> (<strong>let</strong> i = 0; i &lt; numCPUs; i++) {<br> console.log(`Forking process number ${i}â€¦`);<br> cluster.fork();<br> }<br> process.exit();<br>}</pre>\n<h3>Question 37</h3>\n<p>How can you debug you Node JSapplication.</p>\n<p>If you are using vscode like tool for writing node js apps then debugging is easier you can just run debugger in few simpleÂ steps.</p>\n<p>To start debugging, run your Node.js application with theâ€Šâ€”â€ŠinspectÂ flag.</p>\n<p>$ nodeâ€Šâ€”â€Šinspect &lt;your_file&gt;.js</p>\n<p>And you need to add chrome dev tools for that so you can launch debugger on chrome on some port and can do debugging like you do for client side javascript code.</p>\n<p>Another option is node-inspector</p>\n<p>$ npm install -g node-inspector</p>\n<p>$ node-debug app.js</p>\n<p>where app.js is the name of your main Node application JavaScript file.</p>\n<p>The node-debug command will load Node Inspector in your defaultÂ browser.</p>\n<h3>Question 38</h3>\n<p><strong>what are streams and why we should use it with largeÂ data.</strong></p>\n<p>Streams are collections of items such as we have array as collection. The difference is that streams data might not be available all at same time and not necessary they all fit in existing memory. Stream data are not for synchronous execution. Stream are meant to be received over the time asynchronously.</p>\n<p>Stream are powerful tools to send response from apis when you have big data toÂ send.</p>\n<p>This makes streams really powerful when working with large amounts of data, or data thatâ€™s coming from an external source one chunk at a time like file reading of big size. In that case we have to read file in chunks and need to stream that data to send in response.</p>\n<p>They also give us the power of sending data in chunks. Just like we use pipe command in linux and send data of one command to another command, we can do exactly the same in Node withÂ streams.</p>\n<pre><strong>const</strong> fs = require(â€˜fsâ€™);<br><strong>const</strong> server = require(â€˜httpâ€™).createServer();</pre>\n<pre>server.on(â€˜requestâ€™, (req, res) =&gt; {<br> fs.readFile(â€˜./app.txtâ€™, (err, data) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br><br> res.end(data);<br> });<br>});</pre>\n<pre>// using streams //<br>server.on(â€˜requestâ€™, (req, res) =&gt; {<br><strong>const</strong> src = fs.createReadStream(â€˜./xpp.txtâ€™);<br> src.pipe(res);<br>});Question 39</pre>\n<h3>Question 39</h3>\n<p>What are code module in Node JS explain few of them and theirÂ use.</p>\n<p>'Events',</p>\n<p>'fs',</p>\n<p>'http',</p>\n<p>'https',</p>\n<p>'module',</p>\n<p>'net',</p>\n<p>'os',</p>\n<p>'path',</p>\n<p>'stream'</p>\n<p><strong>child_process</strong></p>\n<p>The child_process module provides the ability to spawn child processes in a manner that is similar, butÂ not</p>\n<p>identical, to popen(3).</p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<p><strong>cluster</strong></p>\n<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems the userÂ will</p>\n<p>sometimes want to launch a cluster of Node.js processes to handle the load. The cluster module allows youÂ to</p>\n<p>easily create child processes that all share serverÂ ports.</p>\n<p><a href=\"https://nodejs.org/api/cluster.html\">https://nodejs.org/api/cluster.html</a></p>\n<p><strong>Events</strong></p>\n<p>Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in whichÂ certain</p>\n<p>kinds of objects (called â€œemittersâ€) periodically emit named events that cause Function objects (â€œlistenersâ€) to beÂ Called.</p>\n<p><a href=\"https://nodejs.org/api/events.html\">https://nodejs.org/api/events.html</a></p>\n<p><strong>fs</strong></p>\n<p>File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require(â€˜fsâ€™). All the methods have asynchronous and synchronous forms.</p>\n<p><a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p><strong>http</strong></p>\n<p>The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages.</p>\n<p><strong>readline</strong></p>\n<p>The readline module provides an interface for reading data from a Readable stream (such as process.stdin) one line at aÂ time.</p>\n<p><strong>repl</strong></p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications.</p>\n<p>Reference document</p>\n<p><a href=\"https://nodejs.org/en/docs/\">Docs | Node.js</a></p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<h3>Question 40</h3>\n<p>Explain event loop lifecycle and explain few events inside eventÂ loop.</p>\n<p>In latest release of V8 event loop is also available in JavaScript engine (v8, spiderMonkey etc). Event loop is part of Libuv library &amp; in reality event-loop is the master which uses the JavaScript engines to execute JavaScript code. event loop runs on separateÂ thread.</p>\n<p>When you run node index.js in your console, node start the event-loop and then runs your main module main module from index.js outside the event loop. Once the main module is executed, node will check if the loop is alive if event loop is not alive then node js process simply exit otherwise it will keep listening the eventÂ queue</p>\n<p>At some point during the event loop, the runtime starts handling the messages on the queue, starting with the oldest one. Once that execution is over event is emitted about completion of task and handed over toÂ handler.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*RvIia4KcBmfyhwmI\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b3ea7567675f\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question â€” Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question â€” Set #03</a></li>\n</ul>\n<h3>Question 31</h3>\n<p>Have you used yarn as package manager and how its different fromÂ NPM</p>\n<p>Yarn is just another package manager for installing and managing javascript libraries for application. Yarn is using the same registry that npm does. That means that every package that is a available on npm is the same onÂ Yarn.</p>\n<p>To add a package, run yarn add &lt;package-name&gt;.</p>\n<p>If you need a specific version of the package, you can use yarn add package@version</p>\n<p>yarn also have initÂ command</p>\n<p>The yarn init command will walk you through the creation of a package.json file to configure some information about your package. This is same as we do npm init using npm packageÂ manager</p>\n<p>these are following differences we canÂ see</p>\n<p>Yarn has a few differences from npm. Yarn is doing caching of all installed packages. Yarn is installing the packages simultaneously and when we install packages with Yarn it look like faster than NPM. Both yarn and NPM downloading packages from same NPM repository.</p>\n<p>On the contrary to npm, Yarn provides stability, putting lock on versions of installed packages. The speed is higher while installing packages. It is very important for big projects, which have more dependencies</p>\n<h3>Question 32</h3>\n<p>What are the tools to deploy node js application onÂ server.</p>\n<p>There are many popular tool to deploy node js app on server which will keep node js application up and running and if there is any issue it will restart process like PM2, forever, supervisord</p>\n<p>PM2 providesÂ :</p>\n<ol>\n<li>Built in loadÂ balancer</li>\n<li>Multiple instance of application running on sameÂ port.</li>\n<li>Can run application in clusterÂ mode.</li>\n<li>Can manage deployment of multiple application using singleÂ config.</li>\n<li>Provides multiple deployment options.</li>\n<li>Provides zero downtime on application deployment.</li>\n</ol>\n<p>If you use pm2, you can easily hook it with keymetrics.io monitoring tool to see apiÂ statics.</p>\n<p>npm install -g pm2<br>pm2 startÂ app.js</p>\n<p>Zero-config Load-Balancer Link</p>\n<p>PM2 enable use to create multiple instance to scale up your application by creating instances that share the same server port. Doing this also allow you to restart your app with zero-seconds downtimes.</p>\n<p>PM commands to start/stop/delete application instance</p>\n<p><strong>pm2 start</strong> app.jsâ€Šâ€”â€ŠnameÂ â€œmy-apiâ€</p>\n<p><strong>pm2 start</strong> web.jsâ€Šâ€”â€Šname â€œweb-interfaceâ€</p>\n<p><strong>pm2</strong> stop web-interface.Â â€¦</p>\n<p><strong>pm2</strong> restart web-interface.Â â€¦</p>\n<p><strong>pm2</strong> delete web-interface.Â â€¦</p>\n<p><strong>pm2</strong> restart /http-[1,2]/Â â€¦</p>\n<p><strong>pm2</strong> list # Or <strong>pm2</strong> [list|ls|l|status]</p>\n<p>pm2 list command showing all available instances and pm2 monit command showing monitoring for all running instances</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pzO-erzJeIVNZLnO\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*R4av-BTK2E76Pb8Q\"></figure><p>PM2 has lot of advantages over other tools it gives you everything and its is industry standard for node js deployments.</p>\n<h3>Question 33</h3>\n<p>How to graceful shutdown your Node JS process when something bad happens in code like database connection lost.</p>\n<p>graceful shutdown means whenever node js process shut down in that case we need to shut process down gracefully by closing all db connection by releasing TCP port and releasing all occupied resources so when node process comes up again there should be no anyÂ issues</p>\n<p>graceful shot down can be done in different way</p>\n<p>Shutdown can happen using some code issue like unhandled promise rejection, some javascript code null check missing or database shutdown or forcefully by user using Ctrl +Â C</p>\n<pre>process.on(â€˜unhandledRejectionâ€™, ErrorHandler.unhandledRejection);<br>process.on(â€˜SIGINTâ€™, ErrorHandler.shutdown);<br>process.on(â€˜uncaughtExceptionâ€™, ErrorHandler.onError);</pre>\n<pre>process<br> .on(â€˜unhandledRejectionâ€™, (reason, p) =&gt; {<br> console.error(reason, â€˜Unhandled Rejection at Promiseâ€™, p);<br> // release database connection <br> // release resources<br> });</pre>\n<h3>Question 34</h3>\n<p><strong>How can you make sure of zero downtime while Node JS deployment of your application</strong></p>\n<p>zero downtime means whenever we deploy node js application it stop the application and then start it again in this case there is a downtime of some seconds until application gets connected to database like redis, mysql. Zero downtime canâ€™t be achieved with single instance when we have huge traffic coming forÂ APIs.</p>\n<p>PM2 is powerful tool to manage multiple instances running multiple core of one machine. On multi core system we should always have multiple instance of PM2 to optimally consume multiple cores ofÂ system.</p>\n<ol><li>For having zero downtime we should run application in cluster mode which allows networked Node.js applications (http(s)/tcp/udp server) to be scaled across all CPUs available, without any code modifications. This greatly increases the performance and reliability of your applications, depending on the number of CPUs available</li></ol>\n<p>To enable the cluster mode, just pass the -iÂ option:</p>\n<p>pm2 start app.js -i max <strong>( max means that PM2 will auto detect the number of available CPUs and run as many processes as possible)</strong></p>\n<p>For zero downtime we should use pm2 reload not restart command, reload is different from restart as it will start reloading one by one and not doing reload on all instance together. <strong>pm2 restart app-name</strong>Â ,which kills and restarts the process. <strong>pm2 reload app-name</strong> which restart your workers one by one, and for each worker, wait till the new one has spawned before killing the old one. Using this reload we can serve request by live workers without having any issue in api-services.</p>\n<p>This below mentioned configuration â€œ<strong>ecosystem.config.js</strong>â€ will create max number of instances based on available core on system and run all instances in clusterÂ mode.</p>\n<p><strong>pm2</strong> <strong>startOrReload</strong> ecosystem.config.jsâ€Š<strong>â€”â€Šupdate-env</strong></p>\n<p>This command will start max number of instance if they have not been created yet or reload the existing created instances.â€Šâ€”â€Šupdate-env parameter will reload instance with some newly added configuration.</p>\n<pre>Ecosystem.config.js file:</pre>\n<pre>module.exports = {<br> apps: [<br> {<br> name: â€˜api_appâ€™,<br> script: â€˜app/server.jsâ€™,<br> instances: â€œmaxâ€<br> }<br> ]<br>};</pre>\n<h3>Question 35</h3>\n<p>What is the use of cluster module and how to useÂ it.</p>\n<p>cluster module provide a way to create child process. In some cases we may need to have a child process for running some independent process and want to distribute some process. For that purpose we can use Cluster module which will create another child process and that process is created using like forking aÂ process.</p>\n<p>The cluster module is core node js module like fs,net module. Cluster module contains a set of functions and properties that help us forking processes to take advantage of multi-core systems. Node js runs on single core system but when we have multi core system and in that case to use that multi core system we should create child process which are equal to number of processor inÂ system</p>\n<pre><strong>const</strong> cluster = require(â€˜clusterâ€™);<br><strong>const</strong> http = require(â€˜httpâ€™);<br><strong>const</strong> numCPUs = require(â€˜osâ€™).cpus().length;<br><strong>if</strong> (cluster.isMaster) {<br> masterProcess();<br>} <strong>else</strong> {<br> childProcess(); <br>}<br><strong>function</strong> <strong>masterProcess</strong>() {<br> console.log(`Master ${process.pid} is running`);<br><strong>for</strong> (<strong>let</strong> i = 0; i &lt; numCPUs; i++) {<br> console.log(`Forking process number ${i}â€¦`);<br> cluster.fork();<br> }<br> process.exit();<br>}</pre>\n<h3>Question 37</h3>\n<p>How can you debug you Node JSapplication.</p>\n<p>If you are using vscode like tool for writing node js apps then debugging is easier you can just run debugger in few simpleÂ steps.</p>\n<p>To start debugging, run your Node.js application with theâ€Šâ€”â€ŠinspectÂ flag.</p>\n<p>$ nodeâ€Šâ€”â€Šinspect &lt;your_file&gt;.js</p>\n<p>And you need to add chrome dev tools for that so you can launch debugger on chrome on some port and can do debugging like you do for client side javascript code.</p>\n<p>Another option is node-inspector</p>\n<p>$ npm install -g node-inspector</p>\n<p>$ node-debug app.js</p>\n<p>where app.js is the name of your main Node application JavaScript file.</p>\n<p>The node-debug command will load Node Inspector in your defaultÂ browser.</p>\n<h3>Question 38</h3>\n<p><strong>what are streams and why we should use it with largeÂ data.</strong></p>\n<p>Streams are collections of items such as we have array as collection. The difference is that streams data might not be available all at same time and not necessary they all fit in existing memory. Stream data are not for synchronous execution. Stream are meant to be received over the time asynchronously.</p>\n<p>Stream are powerful tools to send response from apis when you have big data toÂ send.</p>\n<p>This makes streams really powerful when working with large amounts of data, or data thatâ€™s coming from an external source one chunk at a time like file reading of big size. In that case we have to read file in chunks and need to stream that data to send in response.</p>\n<p>They also give us the power of sending data in chunks. Just like we use pipe command in linux and send data of one command to another command, we can do exactly the same in Node withÂ streams.</p>\n<pre><strong>const</strong> fs = require(â€˜fsâ€™);<br><strong>const</strong> server = require(â€˜httpâ€™).createServer();</pre>\n<pre>server.on(â€˜requestâ€™, (req, res) =&gt; {<br> fs.readFile(â€˜./app.txtâ€™, (err, data) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br><br> res.end(data);<br> });<br>});</pre>\n<pre>// using streams //<br>server.on(â€˜requestâ€™, (req, res) =&gt; {<br><strong>const</strong> src = fs.createReadStream(â€˜./xpp.txtâ€™);<br> src.pipe(res);<br>});Question 39</pre>\n<h3>Question 39</h3>\n<p>What are code module in Node JS explain few of them and theirÂ use.</p>\n<p>'Events',</p>\n<p>'fs',</p>\n<p>'http',</p>\n<p>'https',</p>\n<p>'module',</p>\n<p>'net',</p>\n<p>'os',</p>\n<p>'path',</p>\n<p>'stream'</p>\n<p><strong>child_process</strong></p>\n<p>The child_process module provides the ability to spawn child processes in a manner that is similar, butÂ not</p>\n<p>identical, to popen(3).</p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<p><strong>cluster</strong></p>\n<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems the userÂ will</p>\n<p>sometimes want to launch a cluster of Node.js processes to handle the load. The cluster module allows youÂ to</p>\n<p>easily create child processes that all share serverÂ ports.</p>\n<p><a href=\"https://nodejs.org/api/cluster.html\">https://nodejs.org/api/cluster.html</a></p>\n<p><strong>Events</strong></p>\n<p>Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in whichÂ certain</p>\n<p>kinds of objects (called â€œemittersâ€) periodically emit named events that cause Function objects (â€œlistenersâ€) to beÂ Called.</p>\n<p><a href=\"https://nodejs.org/api/events.html\">https://nodejs.org/api/events.html</a></p>\n<p><strong>fs</strong></p>\n<p>File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require(â€˜fsâ€™). All the methods have asynchronous and synchronous forms.</p>\n<p><a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p><strong>http</strong></p>\n<p>The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages.</p>\n<p><strong>readline</strong></p>\n<p>The readline module provides an interface for reading data from a Readable stream (such as process.stdin) one line at aÂ time.</p>\n<p><strong>repl</strong></p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications.</p>\n<p>Reference document</p>\n<p><a href=\"https://nodejs.org/en/docs/\">Docs | Node.js</a></p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<h3>Question 40</h3>\n<p>Explain event loop lifecycle and explain few events inside eventÂ loop.</p>\n<p>In latest release of V8 event loop is also available in JavaScript engine (v8, spiderMonkey etc). Event loop is part of Libuv library &amp; in reality event-loop is the master which uses the JavaScript engines to execute JavaScript code. event loop runs on separateÂ thread.</p>\n<p>When you run node index.js in your console, node start the event-loop and then runs your main module main module from index.js outside the event loop. Once the main module is executed, node will check if the loop is alive if event loop is not alive then node js process simply exit otherwise it will keep listening the eventÂ queue</p>\n<p>At some point during the event loop, the runtime starts handling the messages on the queue, starting with the oldest one. Once that execution is over event is emitted about completion of task and handed over toÂ handler.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*RvIia4KcBmfyhwmI\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b3ea7567675f\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "interview",
              "questions",
              "javascript",
              "nodejs"
          ]
      },
      {
          "title": "Node JS Interview Question â€” Set #03",
          "pubDate": "2018-09-13 15:37:03",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/b0b5af44b402",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question â€” Set #02</a></li>\n</ul>\n<h3>Question 21</h3>\n<p>What is callback hell and how can it be avoided any library which can be used and how to promisify theÂ library</p>\n<p>Callback hell refers to a coding style which we use like when we add nested callbacks in application, Lot of nesting of callback functions create callback hell. The code it becomes difficult to debug and understand in such cases we can use other library to overcome with callback hellÂ problem</p>\n<blockquote>a. Using promises<br>b. Yield operator and Generator functions from ES6<br>c. Modularising code<br>d. Using async library using async waterfall<br>e. by not doing nestedÂ callback</blockquote>\n<p>In javascript most of library supports callback way of writing code like redis-client, mysql-client all such library are callback based so better if we promisify these library and use them withÂ promises</p>\n<a href=\"https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href\">https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href</a><p>We can use util core module to promisify module in node js like we can promisify fs module which provide callback based operation fileread.</p>\n<a href=\"https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href\">https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href</a><p>Now callback based file read write operation become promise based and we need to do â€œ.then()â€ to capture response from resolvedÂ promise.</p>\n<h3>Question 22</h3>\n<p>What are promises and how to use promises for simple AJAX call or for multiple AJAXÂ calls</p>\n<p>Promises give an alternate way to write asynchronous code and it gives advantages over callback.</p>\n<p>We can use promises instead of using callbacks. Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejectedÂ <strong>.then</strong> method gets triggered Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<pre>readFileAsync(filePath, {encoding: â€˜utf8â€™})<br> .then((text) =&gt; {<br> console.log(â€˜CONTENT:â€™, text);<br> })<br> .catch((err) =&gt; {<br> console.log(â€˜ERROR:â€™, err);<br> });<br><strong>function</strong> <strong>readFileAsync</strong>(){<br><strong>return</strong> <strong>new</strong> Promises(<strong>function</strong>(resolve,reject){<br> resolve(â€˜some dataâ€™)<br> })<br>}</pre>\n<h3>Question 23</h3>\n<p>What is global object in Node JS &amp; how it can used to manage environments in application.</p>\n<p>The Global keyword represents the global namespace object, we can get what is in global by opening node terminal or you can do console.log(global) in your application</p>\n<p>when we declare variable using let/const those are module specific modules but when we declare without using let/var they gets added to global namespace of application.</p>\n<p>We can also add few things on global object like runtime environment configuration</p>\n<p>Process, buffer is also part of GlobalÂ object</p>\n<p>Process in very big object having all information about process here we also have global.process.env where we can manage environment specific configuration</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*KY0SPQbYlOW3TfM4\"></figure><p>In our application we pass these env variable while running node application like</p>\n<blockquote>Node index.js node_env=local port=5009</blockquote>\n<p>In this example we will get local when we try to get value of process.env.node_env and will get 5009 when we do process.env.port in ourÂ code.</p>\n<h3>Question 24</h3>\n<p>What are streams and how itâ€™s different from normal apiÂ response</p>\n<p>Streams are just flow of data, steam pipes that let you easily read data from a source and pipe it to a destination. so stream are easy to pipe from one source to another, A stream is nothing but an EventEmitter and implements some specials methods. Depending on the applied methods in node js codeÂ , a stream becomes Readable, Writable, or Duplex (both readable and writable).</p>\n<p>There are different use cases of streams we can use stream to pipe response to apiÂ server.</p>\n<p>For example we can create file reader stream which read file until data in completed from that file and during that we have some events also like read start or data event or errorÂ events</p>\n<pre><strong>var</strong> fs = require(â€œfsâ€);<br><strong>var</strong> data = â€˜â€™;<br><strong>var</strong> readerStream = fs.createReadStream(â€˜input.txtâ€™);<br>readerStream.setEncoding(â€˜UTF8â€™);<br>readerStream.on(â€˜dataâ€™, <strong>function</strong>(chunk) {<br> data += chunk;<br>});<br>readerStream.on(â€˜endâ€™,<strong>function</strong>(){<br> console.log(data);<br>});<br>readerStream.on(â€˜errorâ€™, <strong>function</strong>(err){<br> console.log(err.stack);<br>});</pre>\n<h3>Question 25</h3>\n<p>How we can have separate config for development &amp; production</p>\n<p>environments, configuration file like which manages database connection</p>\n<p>There are different option either you can useÂ .dotenv module to manage configuration for application runtime.</p>\n<p>We can manage different config file based on different environments like dev.properties qa.properties file</p>\n<p>At runtime we should pass process.env.NODE_DNV as either development or production so in code we can load appropriate env file and further we can load its configurations like mongodb url, Mysql connection url which will be different for development and production</p>\n<p>we can require that file and can get configuration object and pass them wherever required.</p>\n<pre><strong>var</strong> config = {<br> production: {<br> mongo : {<br> url: â€˜****â€™<br> }<br> },<br> dev: {<br> mongo : {<br> url: â€˜****â€™<br> }<br> }<br>}<br>exports.get = <strong>function</strong> <strong>get</strong>(env) {<br><strong>return</strong> config[env] || config.default;<br>}<br><strong>const</strong> config = require(â€˜./config/config.jsâ€™).get(process.env.NODE_ENV);<br><strong>const</strong> dbconn = mongoose.createConnection(config.mongo.url);</pre>\n<h3>Question 26</h3>\n<p>What are the modules type which node js currently supporting.</p>\n<p>In Javascript we have modules like es6, commonjs, AMD,UMD.</p>\n<p>The obvious one for Node JS is CommonJS, which is the current module system used by Node JS (the one that uses require and module.exports). CommonJS already is a module system for NodeJS, and ES Modules has to learn to live side by side and interoperate withÂ it</p>\n<p>whatever we do today using module.export &amp; require all are common js modules available on npm repository</p>\n<p>All module downloaded from npmjs.com or npm repository supports common js style of require andÂ exports</p>\n<p>Till now if we want to use ES6 modules in ES6 like using import and export syntax we have to use babel polyfill like babel-register or babel-node as there is no native support for ES6 modules in nodeÂ js</p>\n<p>Node js native doesnâ€™t support ES6 modules or code like import/export</p>\n<p><strong>But now native support is coming but with slight change, these will be called ESM module with extension ofÂ .esm</strong></p>\n<pre><strong>export const spout = â€˜the spoutâ€™<br>export const handle = â€˜the handleâ€™<br>export const tea = â€˜hot teaâ€™</strong></pre>\n<pre><strong>import {handle, spout, tea} from â€˜./01-kettle.mjsâ€™</strong></pre>\n<pre><strong>console.log(handle) // ==&gt; the handle<br>console.log(spout) // ==&gt; the spout<br>console.log(tea) // ==&gt; hot tea</strong></pre>\n<h3>Question 27</h3>\n<p><strong>what is the differences between promises, callback &amp; asyncÂ await</strong></p>\n<p>Async await has been introduced recently and powerful tool to write asynchronous code in synchronous fashion, async await code look like simple synchronous code and it blocks the event loop and implemented on top of promisesÂ only.</p>\n<p>Async functions</p>\n<p>For async we just need to add it before function name as â€œasyncâ€Â function</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>return</strong> 1;<br>}</pre>\n<p>Async before a function always returns a promise. If the code has return &lt;non-promise&gt; in it, then JavaScript automatically wraps it into a resolved promise with thatÂ value.</p>\n<p>let value = awaitÂ promise;</p>\n<p>The keyword await makes JavaScript wait until that promise settles and returns itsÂ result.</p>\n<p>Hereâ€™s example with a promise that resolves in 1Â second:</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>let</strong> promise = <strong>new</strong> Promise((resolve, reject) =&gt; {<br> setTimeout(() =&gt; resolve(â€œdone!â€), 1000)<br> });<br><strong>let</strong> result = <strong>await</strong> promise; // wait till the promise resolves (*)<br> alert(result); // â€œdone!â€<br>}<br>f();</pre>\n<p>Promises are another important tool in javascript to manage asynchronous code.</p>\n<p>Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejectedÂ <strong>.then</strong> method gets triggered, Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<p>Promises allow us to cleanly chain chain subsequent operations while avoiding callback hell and as long as you always return a promise for each of your then blocks, it will continue down theÂ chain.</p>\n<a href=\"https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href\">https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href</a><p>Promises are now supported in native code so no need to add external library. Promises are just representation of asynchronous code which can be in resolved/rejected state and accordinglyÂ .then function will execute with properÂ callback</p>\n<p>Little bit aboutÂ callback</p>\n<p>Node handles all asynchronous operation using callback natively. Callbacks are just functions that you pass to other functions. Example like while reading file using fs core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callbackÂ function</p>\n<h3>Question 28</h3>\n<p><strong>What is event loop, is it part of V8 runtime environment and also available onÂ browser.</strong></p>\n<p>The event loop is provided by the libuv library. It is not part of V8 runtimeÂ env.</p>\n<p>it is single thread entity keeps running in node js process and keep listening the eventÂ queue.</p>\n<p>The Event Loop is the entity that handles external events and converts them into callback invocations. It is a loop that picks events from the event queues and pushes their callbacks into the CallÂ Stack.</p>\n<p>There is only one thread that executes JavaScript code and this is the thread where the event loop is running. The execution of callbacks is done by the eventÂ loop.</p>\n<p>To understand more on event loop you can use this reference link</p>\n<p><a href=\"https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c\">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jhSp7O52Z6XpZopT\"></figure><h3>Question 29</h3>\n<p>what will be the state of Node JS process when event loop is empty and call stack both areÂ empty.</p>\n<p>In such case node js process will exit as it has nothing to process nothing to execute, it is different from any other process, when we start node js process it will start event loop and if there is nothing to execute in event loop it will exit fromÂ there</p>\n<p>To prevent this situation we always create http server where server keeps telling event loop for listening http request events and event loop is not totallyÂ idle.</p>\n<pre><strong>var</strong> http=require(â€˜httpâ€™)<br><strong>var</strong> server=http.createServer(serverFn)<br>server.listen(7000);</pre>\n<h3>Question 30</h3>\n<p><strong>What is call stack, is it part of V8 runtime environmentÂ ?</strong></p>\n<p><strong>Yes call stack is a part of Javascript having either chrome V8 engine or chakraÂ engine.</strong></p>\n<p><strong>The JavaScript engine V8 is a single threaded interpreter having a heap and a single call stack.</strong> The browser additionally provides some APIs like the DOM, AJAX, and Timers. This is main core functionality which is responsible to execute functions using heap and call stack (Stack which use LIFOÂ pattern)</p>\n<p>Call stack operates by principle of Last In, First Out known as LIFO, it says that the last function that gets pushed into the stack is the first to be pop out, when the function returns.It pure stack like data structure based operation.</p>\n<p>We can see that in below example where function calling eachÂ other.</p>\n<p>1. When secondFn() gets executed, an empty stack frame is created. It is the main entry point of theÂ program.</p>\n<p>2. secondFn() then calls firstFn() which is pushed into the stack using LIFOÂ pattern.</p>\n<p>3. firstFn() returns and prints â€œHello from firstFnâ€ to theÂ console.</p>\n<p>4. firstFn() is pop off theÂ stack.</p>\n<p>5. The execution order then move to secondFunction().</p>\n<p>6. secondFn() returns and print â€œThe end from secondFunctionâ€ to theÂ console.</p>\n<p>7. secondFn() is pop off the stack, clearing the memory occupied.</p>\n<pre><strong>function</strong> <strong>firstFn</strong>(){<br><strong>console.log</strong>(â€˜hello from first Fnâ€™);<br>}<br><strong>function</strong> <strong>secondFn</strong>(){<br> firstFn();<br>}<br><strong>function</strong> <strong>thirdFn</strong>(){<br> secondFn();<br>}<br>thirdFn();</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b0b5af44b402\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question â€” Set #02</a></li>\n</ul>\n<h3>Question 21</h3>\n<p>What is callback hell and how can it be avoided any library which can be used and how to promisify theÂ library</p>\n<p>Callback hell refers to a coding style which we use like when we add nested callbacks in application, Lot of nesting of callback functions create callback hell. The code it becomes difficult to debug and understand in such cases we can use other library to overcome with callback hellÂ problem</p>\n<blockquote>a. Using promises<br>b. Yield operator and Generator functions from ES6<br>c. Modularising code<br>d. Using async library using async waterfall<br>e. by not doing nestedÂ callback</blockquote>\n<p>In javascript most of library supports callback way of writing code like redis-client, mysql-client all such library are callback based so better if we promisify these library and use them withÂ promises</p>\n<a href=\"https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href\">https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href</a><p>We can use util core module to promisify module in node js like we can promisify fs module which provide callback based operation fileread.</p>\n<a href=\"https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href\">https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href</a><p>Now callback based file read write operation become promise based and we need to do â€œ.then()â€ to capture response from resolvedÂ promise.</p>\n<h3>Question 22</h3>\n<p>What are promises and how to use promises for simple AJAX call or for multiple AJAXÂ calls</p>\n<p>Promises give an alternate way to write asynchronous code and it gives advantages over callback.</p>\n<p>We can use promises instead of using callbacks. Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejectedÂ <strong>.then</strong> method gets triggered Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<pre>readFileAsync(filePath, {encoding: â€˜utf8â€™})<br> .then((text) =&gt; {<br> console.log(â€˜CONTENT:â€™, text);<br> })<br> .catch((err) =&gt; {<br> console.log(â€˜ERROR:â€™, err);<br> });<br><strong>function</strong> <strong>readFileAsync</strong>(){<br><strong>return</strong> <strong>new</strong> Promises(<strong>function</strong>(resolve,reject){<br> resolve(â€˜some dataâ€™)<br> })<br>}</pre>\n<h3>Question 23</h3>\n<p>What is global object in Node JS &amp; how it can used to manage environments in application.</p>\n<p>The Global keyword represents the global namespace object, we can get what is in global by opening node terminal or you can do console.log(global) in your application</p>\n<p>when we declare variable using let/const those are module specific modules but when we declare without using let/var they gets added to global namespace of application.</p>\n<p>We can also add few things on global object like runtime environment configuration</p>\n<p>Process, buffer is also part of GlobalÂ object</p>\n<p>Process in very big object having all information about process here we also have global.process.env where we can manage environment specific configuration</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*KY0SPQbYlOW3TfM4\"></figure><p>In our application we pass these env variable while running node application like</p>\n<blockquote>Node index.js node_env=local port=5009</blockquote>\n<p>In this example we will get local when we try to get value of process.env.node_env and will get 5009 when we do process.env.port in ourÂ code.</p>\n<h3>Question 24</h3>\n<p>What are streams and how itâ€™s different from normal apiÂ response</p>\n<p>Streams are just flow of data, steam pipes that let you easily read data from a source and pipe it to a destination. so stream are easy to pipe from one source to another, A stream is nothing but an EventEmitter and implements some specials methods. Depending on the applied methods in node js codeÂ , a stream becomes Readable, Writable, or Duplex (both readable and writable).</p>\n<p>There are different use cases of streams we can use stream to pipe response to apiÂ server.</p>\n<p>For example we can create file reader stream which read file until data in completed from that file and during that we have some events also like read start or data event or errorÂ events</p>\n<pre><strong>var</strong> fs = require(â€œfsâ€);<br><strong>var</strong> data = â€˜â€™;<br><strong>var</strong> readerStream = fs.createReadStream(â€˜input.txtâ€™);<br>readerStream.setEncoding(â€˜UTF8â€™);<br>readerStream.on(â€˜dataâ€™, <strong>function</strong>(chunk) {<br> data += chunk;<br>});<br>readerStream.on(â€˜endâ€™,<strong>function</strong>(){<br> console.log(data);<br>});<br>readerStream.on(â€˜errorâ€™, <strong>function</strong>(err){<br> console.log(err.stack);<br>});</pre>\n<h3>Question 25</h3>\n<p>How we can have separate config for development &amp; production</p>\n<p>environments, configuration file like which manages database connection</p>\n<p>There are different option either you can useÂ .dotenv module to manage configuration for application runtime.</p>\n<p>We can manage different config file based on different environments like dev.properties qa.properties file</p>\n<p>At runtime we should pass process.env.NODE_DNV as either development or production so in code we can load appropriate env file and further we can load its configurations like mongodb url, Mysql connection url which will be different for development and production</p>\n<p>we can require that file and can get configuration object and pass them wherever required.</p>\n<pre><strong>var</strong> config = {<br> production: {<br> mongo : {<br> url: â€˜****â€™<br> }<br> },<br> dev: {<br> mongo : {<br> url: â€˜****â€™<br> }<br> }<br>}<br>exports.get = <strong>function</strong> <strong>get</strong>(env) {<br><strong>return</strong> config[env] || config.default;<br>}<br><strong>const</strong> config = require(â€˜./config/config.jsâ€™).get(process.env.NODE_ENV);<br><strong>const</strong> dbconn = mongoose.createConnection(config.mongo.url);</pre>\n<h3>Question 26</h3>\n<p>What are the modules type which node js currently supporting.</p>\n<p>In Javascript we have modules like es6, commonjs, AMD,UMD.</p>\n<p>The obvious one for Node JS is CommonJS, which is the current module system used by Node JS (the one that uses require and module.exports). CommonJS already is a module system for NodeJS, and ES Modules has to learn to live side by side and interoperate withÂ it</p>\n<p>whatever we do today using module.export &amp; require all are common js modules available on npm repository</p>\n<p>All module downloaded from npmjs.com or npm repository supports common js style of require andÂ exports</p>\n<p>Till now if we want to use ES6 modules in ES6 like using import and export syntax we have to use babel polyfill like babel-register or babel-node as there is no native support for ES6 modules in nodeÂ js</p>\n<p>Node js native doesnâ€™t support ES6 modules or code like import/export</p>\n<p><strong>But now native support is coming but with slight change, these will be called ESM module with extension ofÂ .esm</strong></p>\n<pre><strong>export const spout = â€˜the spoutâ€™<br>export const handle = â€˜the handleâ€™<br>export const tea = â€˜hot teaâ€™</strong></pre>\n<pre><strong>import {handle, spout, tea} from â€˜./01-kettle.mjsâ€™</strong></pre>\n<pre><strong>console.log(handle) // ==&gt; the handle<br>console.log(spout) // ==&gt; the spout<br>console.log(tea) // ==&gt; hot tea</strong></pre>\n<h3>Question 27</h3>\n<p><strong>what is the differences between promises, callback &amp; asyncÂ await</strong></p>\n<p>Async await has been introduced recently and powerful tool to write asynchronous code in synchronous fashion, async await code look like simple synchronous code and it blocks the event loop and implemented on top of promisesÂ only.</p>\n<p>Async functions</p>\n<p>For async we just need to add it before function name as â€œasyncâ€Â function</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>return</strong> 1;<br>}</pre>\n<p>Async before a function always returns a promise. If the code has return &lt;non-promise&gt; in it, then JavaScript automatically wraps it into a resolved promise with thatÂ value.</p>\n<p>let value = awaitÂ promise;</p>\n<p>The keyword await makes JavaScript wait until that promise settles and returns itsÂ result.</p>\n<p>Hereâ€™s example with a promise that resolves in 1Â second:</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>let</strong> promise = <strong>new</strong> Promise((resolve, reject) =&gt; {<br> setTimeout(() =&gt; resolve(â€œdone!â€), 1000)<br> });<br><strong>let</strong> result = <strong>await</strong> promise; // wait till the promise resolves (*)<br> alert(result); // â€œdone!â€<br>}<br>f();</pre>\n<p>Promises are another important tool in javascript to manage asynchronous code.</p>\n<p>Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejectedÂ <strong>.then</strong> method gets triggered, Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<p>Promises allow us to cleanly chain chain subsequent operations while avoiding callback hell and as long as you always return a promise for each of your then blocks, it will continue down theÂ chain.</p>\n<a href=\"https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href\">https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href</a><p>Promises are now supported in native code so no need to add external library. Promises are just representation of asynchronous code which can be in resolved/rejected state and accordinglyÂ .then function will execute with properÂ callback</p>\n<p>Little bit aboutÂ callback</p>\n<p>Node handles all asynchronous operation using callback natively. Callbacks are just functions that you pass to other functions. Example like while reading file using fs core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callbackÂ function</p>\n<h3>Question 28</h3>\n<p><strong>What is event loop, is it part of V8 runtime environment and also available onÂ browser.</strong></p>\n<p>The event loop is provided by the libuv library. It is not part of V8 runtimeÂ env.</p>\n<p>it is single thread entity keeps running in node js process and keep listening the eventÂ queue.</p>\n<p>The Event Loop is the entity that handles external events and converts them into callback invocations. It is a loop that picks events from the event queues and pushes their callbacks into the CallÂ Stack.</p>\n<p>There is only one thread that executes JavaScript code and this is the thread where the event loop is running. The execution of callbacks is done by the eventÂ loop.</p>\n<p>To understand more on event loop you can use this reference link</p>\n<p><a href=\"https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c\">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jhSp7O52Z6XpZopT\"></figure><h3>Question 29</h3>\n<p>what will be the state of Node JS process when event loop is empty and call stack both areÂ empty.</p>\n<p>In such case node js process will exit as it has nothing to process nothing to execute, it is different from any other process, when we start node js process it will start event loop and if there is nothing to execute in event loop it will exit fromÂ there</p>\n<p>To prevent this situation we always create http server where server keeps telling event loop for listening http request events and event loop is not totallyÂ idle.</p>\n<pre><strong>var</strong> http=require(â€˜httpâ€™)<br><strong>var</strong> server=http.createServer(serverFn)<br>server.listen(7000);</pre>\n<h3>Question 30</h3>\n<p><strong>What is call stack, is it part of V8 runtime environmentÂ ?</strong></p>\n<p><strong>Yes call stack is a part of Javascript having either chrome V8 engine or chakraÂ engine.</strong></p>\n<p><strong>The JavaScript engine V8 is a single threaded interpreter having a heap and a single call stack.</strong> The browser additionally provides some APIs like the DOM, AJAX, and Timers. This is main core functionality which is responsible to execute functions using heap and call stack (Stack which use LIFOÂ pattern)</p>\n<p>Call stack operates by principle of Last In, First Out known as LIFO, it says that the last function that gets pushed into the stack is the first to be pop out, when the function returns.It pure stack like data structure based operation.</p>\n<p>We can see that in below example where function calling eachÂ other.</p>\n<p>1. When secondFn() gets executed, an empty stack frame is created. It is the main entry point of theÂ program.</p>\n<p>2. secondFn() then calls firstFn() which is pushed into the stack using LIFOÂ pattern.</p>\n<p>3. firstFn() returns and prints â€œHello from firstFnâ€ to theÂ console.</p>\n<p>4. firstFn() is pop off theÂ stack.</p>\n<p>5. The execution order then move to secondFunction().</p>\n<p>6. secondFn() returns and print â€œThe end from secondFunctionâ€ to theÂ console.</p>\n<p>7. secondFn() is pop off the stack, clearing the memory occupied.</p>\n<pre><strong>function</strong> <strong>firstFn</strong>(){<br><strong>console.log</strong>(â€˜hello from first Fnâ€™);<br>}<br><strong>function</strong> <strong>secondFn</strong>(){<br> firstFn();<br>}<br><strong>function</strong> <strong>thirdFn</strong>(){<br> secondFn();<br>}<br>thirdFn();</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b0b5af44b402\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript"
          ]
      },
      {
          "title": "Node JS Interview Question â€” Set #02",
          "pubDate": "2018-09-13 15:25:43",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/b2798d76cd98",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*iSwccAU7q1qFmMxw",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*iSwccAU7q1qFmMxw\"></figure><p><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></p>\n<h3>Question 11</h3>\n<p>how single threaded Node JS handles concurrency when multiple I/O operations happening</p>\n<p>Node provides a single thread to the code we are writing so that code can be written easily and without bottleneck and without I/O blocking Node internally uses multiple POSIX/unix threads for various I/O operations such as network read, database read or file read operations.</p>\n<p>When Node apis or code get I/O request it creates a thread from thread pool to perform that asynchronous operation and once the operation is done, it pushes the result to the event queue. On each such event, event loop runs and checks the queue and if the execution stack of Node is empty then it adds the queue result to execution stack.</p>\n<p>This is how Node manages concurrency.</p>\n<p>ReferenceÂ : <a href=\"https://strongloop.com/strongblog/node-js-is-faster-than-java/\">https://strongloop.com/strongblog/node-js-is-faster-than-java/</a></p>\n<p>Request modeling is different, In node js its not creating separate thread for every request, just running event loop and delegating to async thread for running asyncÂ tasks.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*fr65aKR3wSjSnulo\"></figure><h3>Question 12</h3>\n<p>What is Node JS callback and how it helps to run AsyncÂ tasks</p>\n<p>Callback is a Node.js function which can be created with plain javascript code. While writing callback you donâ€™t need node js environment. Itâ€™s just higher order function which takes function as argument and return callback functionÂ . This function is used to avoid I/O or network blocking and allows next instruction toÂ run</p>\n<p>Node JS handle all asynchronous calls via callback natively. Callbacks are just functions that you pass to other functions. which we call as higher order function in javascript. Example on callback is while reading file using fs node js core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callbackÂ function</p>\n<p>Node.js use callback function extensively. Node APIs are written to support callbacks of NodeÂ JS.</p>\n<pre><strong>var</strong> fs = require(â€œfsâ€);<br> fs.readFile(â€˜app.txtâ€™, <strong>function</strong> (err, data) {<br><strong>if</strong> (err) <strong>return</strong> console.error(err);<br> console.log(data.toString());<br> });<br> console.log(â€œProgram Endedâ€);</pre>\n<h3>Question 13</h3>\n<p>Explain basic async apis in javascript like setTimeout, setImmediate &amp; setInterval</p>\n<p>The setTimeout &amp; setInterval are the 2 timers functions.these function are being used to create timer function.</p>\n<p><strong>setTimeout</strong>Â :- This function is used to delay the execution of code written under it. This will execute once after the defined delay in milliseconds.</p>\n<p><strong>After 1 second we will get console message sayingÂ â€œHelloâ€</strong></p>\n<pre><strong>function</strong> <strong>sayHi</strong>() {<br> console.log(â€˜Helloâ€™);<br>}<br>setTimeout(sayHi, 1000);</pre>\n<pre><strong>setInterval </strong>:-<strong> </strong>if you want to execute a function many times or unlimited times then we can use .<strong>setInterval</strong>() by passing the interval duration.</pre>\n<p>This function will keep executing after every second and print value of i onÂ console</p>\n<pre>let i = 0;<br>function increment() {<br>i++;<br><em>console</em>.log(i);<br>}<br>var myVar = setInterval(increment, 1000);<br>// clearInterval(myVar);</pre>\n<p>clearInterval method will be used to clearout the execution of method from setInterval</p>\n<p><strong>setImmediate</strong>() and setTimeout() are based on the eventÂ loop.</p>\n<p>Another important method in setImmediate, we use setImmediate if we want to queue the function behind whatever I/O event callbacks that are already in the eventÂ queue.</p>\n<p>we can use process.nextTick to effectively queue the function at the head of the event queue so that it executes immediately after the current function completes. It queues them immediately after the last I/O handler somewhat like process.nextTick. So it isÂ faster.</p>\n<h3>Question 14</h3>\n<p>What is REPL in Node JSand how it helps to runÂ code.</p>\n<p>Node.js comes with environment called REPL (aka Node shell). REPL stands for Read-Eval-Print-Loop, its easiest way to run node js code onÂ console.</p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications. It can be accessedÂ using:</p>\n<p>will give you a result which is similar to the one you will get in the console of Google Chrome browser, it look like chrome console without browser basedÂ apis</p>\n<p><strong>const</strong> repl = require(â€˜replâ€™);</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*7l-UKBgt62cia0fG\"></figure><h3>Question 15</h3>\n<p>What are core and important modules in node JS which used frequently and explain difference between core module and user definedÂ module</p>\n<p>Node.js being lightweight framework. All the core modules include minimum functionalities of Node.js. These core modules are compiled into its binary distribution and load automatically when Node.js processÂ starts</p>\n<blockquote>\n<strong>Cluster </strong>The cluster module helps us to create children process that runs simultaneously and share the same server port. So using this we can create process running on same port, As node js is single threaded and efficiently use memory by consuming single core only but when we are running on multi core system in such case to take advantage of multi-core systems Cluster module allows you to easily create child processes that each runs on their own single thread, to handle theÂ load.</blockquote>\n<p>Cryptoâ€Šâ€”â€ŠTo handle OpenSSL cryptographic functions<br>Dgramâ€Šâ€”â€ŠProvides implementation of UDP datagram sockets<br>Dnsâ€Šâ€”â€ŠTo do DNS lookups and name resolution functions<br>Domainâ€Šâ€”â€ŠDeprecated. To handle unhandled errors<br>Eventsâ€Šâ€”â€ŠTo handle events<br>Fsâ€Šâ€”â€ŠTo handle the file system<br>Httpâ€Šâ€”â€ŠTo make Node.js act as an HTTP server<br>Httpsâ€Šâ€”â€ŠTo make Node.js act as an HTTPS server.<br>Netâ€Šâ€”â€ŠTo create servers and clients<br>Osâ€Šâ€”â€ŠProvides information about the operation system<br>Pathâ€Šâ€”â€ŠTo handle fileÂ paths</p>\n<p>All above mentioned are code module in node js as they are coming bundled with node js installation. User defined module are those which we are creating in node js application and writing module.export in file and again making them require in anotherÂ file.</p>\n<p>ReferenceÂ : <a href=\"https://nodejs.org/api/synopsis.html\">https://nodejs.org/api/synopsis.html</a></p>\n<h3>Question 16</h3>\n<p>Explain events in Node JS and how events are helping us to create event drivenÂ system.</p>\n<p>every action has reaction similarly every event has it handler to catch the action and take action onÂ it.</p>\n<p>In node js we have event emitter which is used to emit event and further that event can be captured to perform some operation.</p>\n<p>Events can be compared by simple socker.io example when server broadcast a message it can be captured by all client who are subscribing to thatÂ channel.</p>\n<p>Node.js has a built-in core module known as â€œEventsâ€, where you can create, fire, and listen for your ownÂ events.</p>\n<p>Its plain and simple we create events and written handler at another place to capture thatÂ event</p>\n<p>To include the built-in Events module use the require() method. All event properties and methods are an instance of EventEmitter object available on events so to be able to access these properties and methods we need to create an EventEmitter object:</p>\n<pre><strong>var</strong> events = require(â€˜eventsâ€™);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<p>Here is the example where we are emitting event name â€œscreamâ€ and there is a handler my eventHandler which is capturing this event and processing task. These events are like fire and forget you fire and forgetÂ them.</p>\n<pre><strong>var</strong> events = require(â€˜eventsâ€™);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<pre>//Create an event handler:<br><strong>var</strong> myEventHandler = <strong>function</strong> () {<br> console.log(â€˜I hear a scream!â€™);<br>}</pre>\n<pre>//Assign the event handler to an event:<br>eventEmitter.on(â€˜screamâ€™, myEventHandler);</pre>\n<pre>//Fire the â€˜screamâ€™ event:<br>eventEmitter.emit(â€˜screamâ€™);</pre>\n<h3>Question 17</h3>\n<p>How we can read file in synchronous way &amp; asynchronous way using fsÂ module.</p>\n<p>The normal behaviour in Node.js is to read in the content of a file in a non-blocking,asynchronous way. That is to tell Node to read the file and return callback once you are done with reading file, there are different events also like file read started or file readÂ over.</p>\n<p>We use core module fs and fs.readfile provides asynchronous way of readingÂ file</p>\n<p>For this we can use the readFile method of the fs coreÂ module</p>\n<p>Node js core module fs takes 3 arguments, These arguments are name of the file (â€˜app.txtâ€™ in this case), the encoding of the file (â€˜utf8â€™), and a callback function as argument. This function which is a callback function going to be called when the file-reading operation has finished and we will see file content printed on terminal.</p>\n<p>As this operation is non I/O blocking and asynchronous in nature, this will be process using event loop but execution will not be blocked we will see message â€œfile read is overâ€ before getting file contents onÂ terminal</p>\n<pre><strong>var</strong> fs = require(â€˜fsâ€™);<br>fs.readFile(app.txt, â€˜utf8â€™, <strong>function</strong>(err, contents) {<br> console.log(contents);<br>});<br>console.log(â€˜file read is Overâ€™);</pre>\n<p>There is another way to use blocking file read operation using fs.readFileSync which will read file in synchronous way and it block the execution until unless file read operation isÂ over.</p>\n<pre><strong>var</strong> fs = require(â€˜fsâ€™);<br><strong>var</strong> contents = fs.readFileSync(â€˜app.txtâ€™, â€˜utf8â€™);<br>console.log(contents);</pre>\n<pre>console.log(â€˜file read is Overâ€™);</pre>\n<h3>Question 18</h3>\n<p>How to capture command line arguments while executing node jsÂ process.</p>\n<p>The arguments are stored in process.argv when you pass args with nodeÂ command</p>\n<p>like node index.js â€œhelloâ€Â â€œworldâ€</p>\n<p>[runtime] [script_name] [argument-1 argument-2 argument-3Â â€¦ argument-n]</p>\n<p>process.argv is an array containing the command line arguments. The first element will be â€˜nodeâ€™, the second element will be the name of the JavaScript file. The next elements will be any additional command line arguments.</p>\n<p>we can get all arguments printed using thisÂ Loop</p>\n<p>and we can pass information to an application before it starts. This is particularly useful if you want to perform some settings before starting application like passing env andÂ port</p>\n<pre>process.argv.forEach(<strong>function</strong> (val, index, array) {<br> console.log(index + â€˜: â€˜ + val);<br>});</pre>\n<h3>Question 19</h3>\n<p>What is error check first in callback handler defined in Node JSÂ code.</p>\n<p>generally, the first argument to any callback handler is an an error object and there is a reason to pass first argument as error object in callback handler which can be either null or error object so while dealing with callback we can check if we have received null or some errorÂ object</p>\n<p>if we get error object then we will perform our action based on error. Error handling by a typical callback handler could be asÂ follows:</p>\n<pre><strong>function</strong> <strong>callback</strong>(err, results) {<br> // usually weâ€™ll check for the error before handling results<br><strong>if</strong>(err) {<br> // handle error somehow and return<br> }<br> // no error, perform standard callback handling<br>}</pre>\n<p>This is applied to all callbacks we write in our code and its part of ESLint configuration which force developer to write code in thisÂ way.</p>\n<h3>Question 20</h3>\n<p>What are different module pattern in javascript, can you explain common JSÂ modules.</p>\n<p>In JavaScript, the word â€œmodulesâ€ refers to small units of independent, reusable code. They are the foundation of many JavaScript design patterns and are critically necessary when building any non-trivial JavaScript-based application.</p>\n<p>We have different module pattern in javascript like commonjs, AMD, UMD and ES6Â modules</p>\n<p>A CommonJS module is essentially a reusable piece of code can be fetched from either nomjs.com repository or created locally. From module we can exports specific objects, making them available for other modules to require in their programs. While writing node js code you have seen this and may be very familiar with thisÂ format.</p>\n<p>Using Common JS every JavaScript file stores modules in its own unique module context (just like wrapping it in a closure).We use module.export to export module and require to require that module in anotherÂ file.</p>\n<p>module.export and require syntax we use everywhere in Node js Code, all common js modules are imported in such a wayÂ only</p>\n<pre><strong>var</strong> app = require(â€˜./appâ€™)<br><strong>function</strong> <strong>myModule</strong>() {<br><strong>this</strong>.hello = <strong>function</strong>() {<br><strong>return</strong> â€˜hello!â€™;<br> }<br><strong>this</strong>.goodbye = <strong>function</strong>() {<br><strong>return</strong> â€˜goodbye!â€™;<br> }<br>}<br>module.exports = myModule;</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b2798d76cd98\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*iSwccAU7q1qFmMxw\"></figure><p><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question â€” Set #01</a></p>\n<h3>Question 11</h3>\n<p>how single threaded Node JS handles concurrency when multiple I/O operations happening</p>\n<p>Node provides a single thread to the code we are writing so that code can be written easily and without bottleneck and without I/O blocking Node internally uses multiple POSIX/unix threads for various I/O operations such as network read, database read or file read operations.</p>\n<p>When Node apis or code get I/O request it creates a thread from thread pool to perform that asynchronous operation and once the operation is done, it pushes the result to the event queue. On each such event, event loop runs and checks the queue and if the execution stack of Node is empty then it adds the queue result to execution stack.</p>\n<p>This is how Node manages concurrency.</p>\n<p>ReferenceÂ : <a href=\"https://strongloop.com/strongblog/node-js-is-faster-than-java/\">https://strongloop.com/strongblog/node-js-is-faster-than-java/</a></p>\n<p>Request modeling is different, In node js its not creating separate thread for every request, just running event loop and delegating to async thread for running asyncÂ tasks.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*fr65aKR3wSjSnulo\"></figure><h3>Question 12</h3>\n<p>What is Node JS callback and how it helps to run AsyncÂ tasks</p>\n<p>Callback is a Node.js function which can be created with plain javascript code. While writing callback you donâ€™t need node js environment. Itâ€™s just higher order function which takes function as argument and return callback functionÂ . This function is used to avoid I/O or network blocking and allows next instruction toÂ run</p>\n<p>Node JS handle all asynchronous calls via callback natively. Callbacks are just functions that you pass to other functions. which we call as higher order function in javascript. Example on callback is while reading file using fs node js core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callbackÂ function</p>\n<p>Node.js use callback function extensively. Node APIs are written to support callbacks of NodeÂ JS.</p>\n<pre><strong>var</strong> fs = require(â€œfsâ€);<br> fs.readFile(â€˜app.txtâ€™, <strong>function</strong> (err, data) {<br><strong>if</strong> (err) <strong>return</strong> console.error(err);<br> console.log(data.toString());<br> });<br> console.log(â€œProgram Endedâ€);</pre>\n<h3>Question 13</h3>\n<p>Explain basic async apis in javascript like setTimeout, setImmediate &amp; setInterval</p>\n<p>The setTimeout &amp; setInterval are the 2 timers functions.these function are being used to create timer function.</p>\n<p><strong>setTimeout</strong>Â :- This function is used to delay the execution of code written under it. This will execute once after the defined delay in milliseconds.</p>\n<p><strong>After 1 second we will get console message sayingÂ â€œHelloâ€</strong></p>\n<pre><strong>function</strong> <strong>sayHi</strong>() {<br> console.log(â€˜Helloâ€™);<br>}<br>setTimeout(sayHi, 1000);</pre>\n<pre><strong>setInterval </strong>:-<strong> </strong>if you want to execute a function many times or unlimited times then we can use .<strong>setInterval</strong>() by passing the interval duration.</pre>\n<p>This function will keep executing after every second and print value of i onÂ console</p>\n<pre>let i = 0;<br>function increment() {<br>i++;<br><em>console</em>.log(i);<br>}<br>var myVar = setInterval(increment, 1000);<br>// clearInterval(myVar);</pre>\n<p>clearInterval method will be used to clearout the execution of method from setInterval</p>\n<p><strong>setImmediate</strong>() and setTimeout() are based on the eventÂ loop.</p>\n<p>Another important method in setImmediate, we use setImmediate if we want to queue the function behind whatever I/O event callbacks that are already in the eventÂ queue.</p>\n<p>we can use process.nextTick to effectively queue the function at the head of the event queue so that it executes immediately after the current function completes. It queues them immediately after the last I/O handler somewhat like process.nextTick. So it isÂ faster.</p>\n<h3>Question 14</h3>\n<p>What is REPL in Node JSand how it helps to runÂ code.</p>\n<p>Node.js comes with environment called REPL (aka Node shell). REPL stands for Read-Eval-Print-Loop, its easiest way to run node js code onÂ console.</p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications. It can be accessedÂ using:</p>\n<p>will give you a result which is similar to the one you will get in the console of Google Chrome browser, it look like chrome console without browser basedÂ apis</p>\n<p><strong>const</strong> repl = require(â€˜replâ€™);</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*7l-UKBgt62cia0fG\"></figure><h3>Question 15</h3>\n<p>What are core and important modules in node JS which used frequently and explain difference between core module and user definedÂ module</p>\n<p>Node.js being lightweight framework. All the core modules include minimum functionalities of Node.js. These core modules are compiled into its binary distribution and load automatically when Node.js processÂ starts</p>\n<blockquote>\n<strong>Cluster </strong>The cluster module helps us to create children process that runs simultaneously and share the same server port. So using this we can create process running on same port, As node js is single threaded and efficiently use memory by consuming single core only but when we are running on multi core system in such case to take advantage of multi-core systems Cluster module allows you to easily create child processes that each runs on their own single thread, to handle theÂ load.</blockquote>\n<p>Cryptoâ€Šâ€”â€ŠTo handle OpenSSL cryptographic functions<br>Dgramâ€Šâ€”â€ŠProvides implementation of UDP datagram sockets<br>Dnsâ€Šâ€”â€ŠTo do DNS lookups and name resolution functions<br>Domainâ€Šâ€”â€ŠDeprecated. To handle unhandled errors<br>Eventsâ€Šâ€”â€ŠTo handle events<br>Fsâ€Šâ€”â€ŠTo handle the file system<br>Httpâ€Šâ€”â€ŠTo make Node.js act as an HTTP server<br>Httpsâ€Šâ€”â€ŠTo make Node.js act as an HTTPS server.<br>Netâ€Šâ€”â€ŠTo create servers and clients<br>Osâ€Šâ€”â€ŠProvides information about the operation system<br>Pathâ€Šâ€”â€ŠTo handle fileÂ paths</p>\n<p>All above mentioned are code module in node js as they are coming bundled with node js installation. User defined module are those which we are creating in node js application and writing module.export in file and again making them require in anotherÂ file.</p>\n<p>ReferenceÂ : <a href=\"https://nodejs.org/api/synopsis.html\">https://nodejs.org/api/synopsis.html</a></p>\n<h3>Question 16</h3>\n<p>Explain events in Node JS and how events are helping us to create event drivenÂ system.</p>\n<p>every action has reaction similarly every event has it handler to catch the action and take action onÂ it.</p>\n<p>In node js we have event emitter which is used to emit event and further that event can be captured to perform some operation.</p>\n<p>Events can be compared by simple socker.io example when server broadcast a message it can be captured by all client who are subscribing to thatÂ channel.</p>\n<p>Node.js has a built-in core module known as â€œEventsâ€, where you can create, fire, and listen for your ownÂ events.</p>\n<p>Its plain and simple we create events and written handler at another place to capture thatÂ event</p>\n<p>To include the built-in Events module use the require() method. All event properties and methods are an instance of EventEmitter object available on events so to be able to access these properties and methods we need to create an EventEmitter object:</p>\n<pre><strong>var</strong> events = require(â€˜eventsâ€™);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<p>Here is the example where we are emitting event name â€œscreamâ€ and there is a handler my eventHandler which is capturing this event and processing task. These events are like fire and forget you fire and forgetÂ them.</p>\n<pre><strong>var</strong> events = require(â€˜eventsâ€™);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<pre>//Create an event handler:<br><strong>var</strong> myEventHandler = <strong>function</strong> () {<br> console.log(â€˜I hear a scream!â€™);<br>}</pre>\n<pre>//Assign the event handler to an event:<br>eventEmitter.on(â€˜screamâ€™, myEventHandler);</pre>\n<pre>//Fire the â€˜screamâ€™ event:<br>eventEmitter.emit(â€˜screamâ€™);</pre>\n<h3>Question 17</h3>\n<p>How we can read file in synchronous way &amp; asynchronous way using fsÂ module.</p>\n<p>The normal behaviour in Node.js is to read in the content of a file in a non-blocking,asynchronous way. That is to tell Node to read the file and return callback once you are done with reading file, there are different events also like file read started or file readÂ over.</p>\n<p>We use core module fs and fs.readfile provides asynchronous way of readingÂ file</p>\n<p>For this we can use the readFile method of the fs coreÂ module</p>\n<p>Node js core module fs takes 3 arguments, These arguments are name of the file (â€˜app.txtâ€™ in this case), the encoding of the file (â€˜utf8â€™), and a callback function as argument. This function which is a callback function going to be called when the file-reading operation has finished and we will see file content printed on terminal.</p>\n<p>As this operation is non I/O blocking and asynchronous in nature, this will be process using event loop but execution will not be blocked we will see message â€œfile read is overâ€ before getting file contents onÂ terminal</p>\n<pre><strong>var</strong> fs = require(â€˜fsâ€™);<br>fs.readFile(app.txt, â€˜utf8â€™, <strong>function</strong>(err, contents) {<br> console.log(contents);<br>});<br>console.log(â€˜file read is Overâ€™);</pre>\n<p>There is another way to use blocking file read operation using fs.readFileSync which will read file in synchronous way and it block the execution until unless file read operation isÂ over.</p>\n<pre><strong>var</strong> fs = require(â€˜fsâ€™);<br><strong>var</strong> contents = fs.readFileSync(â€˜app.txtâ€™, â€˜utf8â€™);<br>console.log(contents);</pre>\n<pre>console.log(â€˜file read is Overâ€™);</pre>\n<h3>Question 18</h3>\n<p>How to capture command line arguments while executing node jsÂ process.</p>\n<p>The arguments are stored in process.argv when you pass args with nodeÂ command</p>\n<p>like node index.js â€œhelloâ€Â â€œworldâ€</p>\n<p>[runtime] [script_name] [argument-1 argument-2 argument-3Â â€¦ argument-n]</p>\n<p>process.argv is an array containing the command line arguments. The first element will be â€˜nodeâ€™, the second element will be the name of the JavaScript file. The next elements will be any additional command line arguments.</p>\n<p>we can get all arguments printed using thisÂ Loop</p>\n<p>and we can pass information to an application before it starts. This is particularly useful if you want to perform some settings before starting application like passing env andÂ port</p>\n<pre>process.argv.forEach(<strong>function</strong> (val, index, array) {<br> console.log(index + â€˜: â€˜ + val);<br>});</pre>\n<h3>Question 19</h3>\n<p>What is error check first in callback handler defined in Node JSÂ code.</p>\n<p>generally, the first argument to any callback handler is an an error object and there is a reason to pass first argument as error object in callback handler which can be either null or error object so while dealing with callback we can check if we have received null or some errorÂ object</p>\n<p>if we get error object then we will perform our action based on error. Error handling by a typical callback handler could be asÂ follows:</p>\n<pre><strong>function</strong> <strong>callback</strong>(err, results) {<br> // usually weâ€™ll check for the error before handling results<br><strong>if</strong>(err) {<br> // handle error somehow and return<br> }<br> // no error, perform standard callback handling<br>}</pre>\n<p>This is applied to all callbacks we write in our code and its part of ESLint configuration which force developer to write code in thisÂ way.</p>\n<h3>Question 20</h3>\n<p>What are different module pattern in javascript, can you explain common JSÂ modules.</p>\n<p>In JavaScript, the word â€œmodulesâ€ refers to small units of independent, reusable code. They are the foundation of many JavaScript design patterns and are critically necessary when building any non-trivial JavaScript-based application.</p>\n<p>We have different module pattern in javascript like commonjs, AMD, UMD and ES6Â modules</p>\n<p>A CommonJS module is essentially a reusable piece of code can be fetched from either nomjs.com repository or created locally. From module we can exports specific objects, making them available for other modules to require in their programs. While writing node js code you have seen this and may be very familiar with thisÂ format.</p>\n<p>Using Common JS every JavaScript file stores modules in its own unique module context (just like wrapping it in a closure).We use module.export to export module and require to require that module in anotherÂ file.</p>\n<p>module.export and require syntax we use everywhere in Node js Code, all common js modules are imported in such a wayÂ only</p>\n<pre><strong>var</strong> app = require(â€˜./appâ€™)<br><strong>function</strong> <strong>myModule</strong>() {<br><strong>this</strong>.hello = <strong>function</strong>() {<br><strong>return</strong> â€˜hello!â€™;<br> }<br><strong>this</strong>.goodbye = <strong>function</strong>() {<br><strong>return</strong> â€˜goodbye!â€™;<br> }<br>}<br>module.exports = myModule;</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b2798d76cd98\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript"
          ]
      },
      {
          "title": "Node JS Interview Question â€” Set #01",
          "pubDate": "2018-09-13 15:11:51",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/73c2b87c6ae3",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*37d-Wo6TFWi6oaXR",
          "description": "\n<h3>50 Essential Node-JS Interview Questions-Part-#1</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*37d-Wo6TFWi6oaXR\"></figure><h3>Question 1</h3>\n<p>What is NPM &amp; how its being used with NodeÂ JS</p>\n<p>npm is the package manager for JavaScript based application and the worldâ€™s largest software registry having thousands of javascript modules.You can Discover packages of reusable codeâ€Šâ€”â€Šand assemble them in powerful newÂ ways.</p>\n<p>NPM is powerful package manager to install new package for your application. It will give you common jsÂ modules.</p>\n<p>NPM gives you capability to initialize application using package.json.</p>\n<p>NPM and yarn are most popular package manager to manage javascript modules.If you are creating some reusable code and wanted to share with others you can create NPM module and push in to NPM and that module can be used byÂ others.</p>\n<pre>npm init</pre>\n<pre>npm install -save react</pre>\n<pre>npm instal -g webpack</pre>\n<pre>npm instal â€” save-dev gulp</pre>\n<p>We can install package globally, Locally and install package in dev dependencies.</p>\n<p>Global packages will be available system wide and can be accessed on system cli like webpack and webpack-dev-server modules.</p>\n<p>npm as package manager install new package for application which can be added globally locally in your application as local module or local dependencies.</p>\n<p>Node js is using NPM and its coming with node version as default package manager to manage dependencies locally and globally.</p>\n<h3>Question 2</h3>\n<p>What is Node.JS? When should we use NodeÂ JS</p>\n<p>Node.js is a server side language based on Googleâ€™s V8 JavaScript engine.</p>\n<p>It is used to build scalable programs and need to run very fast. Its built on top of V8 runtime engine whose baseline in libio &amp; libuv Libraries for cÂ ++.</p>\n<p>Node js can be used to build api and application required real time interface like reading live data, streaming data and doing socket communication.</p>\n<p>Node js should never be used with CPU intensive tasks like reading huge files and reading lot of data from database and sending it somewhere else.</p>\n<p>Node.js is a highly efficient which can scale enough &amp; provide non-blocking I/O running on single thread event loop that was built on top of Google Chrome V8 engine and its ECMAScript.</p>\n<ul>\n<li>Node JS provide scalable applications</li>\n<li>Node JS is server side javascript and single threaded.</li>\n<li>Node JS adds non I/O blocking platform.</li>\n<li>Node JS is built on top of v8 chromeÂ engine.</li>\n<li>Node JS provides faster way to create REST APIs and have good stack of library to support applications.</li>\n<li>Node JS providing faster application development and can be used in microservices like environments.</li>\n</ul>\n<h3>Question 3</h3>\n<p>What is of Node js platform stack, what are different libraries it isÂ using.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/256/0*8D6zO4umZz-oBEPT\"></figure><p>Node JS using V8 runtime Engine same as chrome is using, it built on top of same chromeÂ engine.</p>\n<p>Itâ€™s an open source JIT(Just In Time) compiler written in c++ which has outperformed PHP, Ruby and python performance wise. V8 compiler compiles Javascript directly into assembly level code. V8 Runtime environment comprises into 3 major component</p>\n<p>CompilerÂ : dissects the JSÂ code</p>\n<p>OptimizerÂ : Optimizer called crankshaft create abstract syntax tree(AST) which further converts to SSAÂ : static single assignment and gets optimized</p>\n<p>Garbage CollectorÂ : it removes dead objects from new space and puts into old space. Garbage collector play vital role in keeping Node Js lightweight.</p>\n<p>Base library are c++ library and libeio managing thread pool so javascript engine here is single thread but internally its managing threadÂ pool.</p>\n<p>2. Libuv/libioÂ : A C++Â library</p>\n<p>This library handles Nodeâ€™s asynchronous I/O operation and main event loop. There are thread pool reserve in Libuv which handles the thread allocation to individual I/O operations.</p>\n<p>On top of c++ library node js has binding with http, socket io binding which are being invoked by core modules of node js like fs, net, dns, socket.io, http.</p>\n<p>Node js standard library are written in javascript to access c++ library interface and access interface as Node js will be running on server not on simple browser accessing html and javascript.</p>\n<h3>Question 4</h3>\n<p>What is Node JS Architecture.</p>\n<p>Node is single threaded and based on non I/O blocking way of dealing with operation.</p>\n<p>It is fast and scalable while running on single thread and doing I/O operation like database read, file read in asynchronous way using eventÂ loop.</p>\n<p>Node JS is single threaded or its javascript interface is single threaded, but this is a half truth, actually it is event-driven and single-threaded with background workers. The Event loop is single-threaded but most of the I/O works run on separate threads, because the I/O APIs in Node.js are asynchronous/non-blocking by design, in order to accommodate the eventÂ loop.</p>\n<p>Node js event loop is feature of Node js base library, Node js is running on single threaded environment and can provide more performance using this single threaded event driven model, Node js manages event loop keeps running in search of asynchronous request.</p>\n<p>Node js event loop keeps running and whenever any asynchronous request comes its places in event loop if event loop is not busy and gets processed and further notified once execution over, Once you are getting multiple async requests then it pushed all request to event queue and start processing request one by one without blocking the code execution.</p>\n<p>Event loop is a part of Libeio library and running as single thread keeps waiting for async request ina cycle once it sees anything coming it will processÂ it.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*VOFPFmZjhWpUXXhH\"></figure><h3>Question 5</h3>\n<p>Explain in depth about event loop mechanism in NodeÂ JS.</p>\n<p>The Event Loop is a queue of callback functions. When an async function executes like setTimeout, the callback function is pushed to the queue. The JavaScript engine doesnâ€™t continue processing the event loop until the code after an async function has executed.</p>\n<p>Event-loop is the main part of the node js system. it keeps running and executing as long as node js process are active in memory. Itâ€™s responsible for handling asynchronous operations in application like http call, I/O operation and database read. These all request will be queued to the event loop waiting to be executed on the next free I/O, on execution completion the event loop will got notified to trigger a callback to the main function.</p>\n<pre>request(â€˜http://www.google.com', function(error, response, body) {</pre>\n<pre>console.log(body);</pre>\n<pre>});<br>console.log(â€˜Done!â€™);</pre>\n<p>In above code example, using request module we are making an http call on google.com url. It is asynchronous operation as you will reading data from network. This task will be pushed to event queue if event loop is busy in processing tasks &amp; further once event loop if free, event queue will send that I/O request to event loop for execution. we will get response from the callback added in this code, it will get executed once we have response from I/OÂ task.</p>\n<p>Node js runtime execution is not blocked by asynchronous tasks, it will move to the next statement like in above example after running http call using request module it will move to console.log statement. we will see output on console and after sometime we will be notified with this callback with data coming from networkÂ request.</p>\n<h3>Question 6</h3>\n<ol><li>What is the role of package.json and what are NPMÂ scripts</li></ol>\n<p>This file package.json has the information about the project. this gives information to npm that allows it to identify the project as well as handle the projectâ€™s dependencies either local or devdependencies.</p>\n<p>Some of the fields are basic information like name, name, description, author and dependencies, script and some metaÂ tags.</p>\n<p>if you install application using npm then all the dependencies listed will be installed as well. Additionally, after installation it create./node_modules directory.</p>\n<p>Package.json is just json file having meta information about application. Here main part is npm scripts which are important part and will be executing our application with different commands. Like running node js process either we write node index.js on terminal directly or we just run npm runÂ start.</p>\n<p>Which one isÂ better</p>\n<p>We use npm scripts to automate our tasks and list all them together in npm scripts where we can execute them using npm run &lt;task-name&gt;, npm scripts are powerful you can add pre and post hooks for these tasks. These will work like task runners we used to have like gulp andÂ grunt.</p>\n<pre>{<br> â€œnameâ€: â€œnode-js-sampleâ€,<br> â€œversionâ€: â€œ0.2.0â€,<br> â€œdescriptionâ€: â€œA sample Node.js app using Express 4â€,<br> â€œmainâ€: â€œindex.jsâ€,<br> â€œscriptsâ€: {<br> â€œstartâ€: â€œnode index.jsâ€<br> },<br> â€œdependenciesâ€: {<br> â€œexpressâ€: â€œâ´.13.3â€<br> },<br> â€œenginesâ€: {<br> â€œnodeâ€: â€œ4.0.0â€<br> },<br> â€œrepositoryâ€: {<br> â€œtypeâ€: â€œgitâ€,<br> â€œurlâ€: â€œhttps://github.com/heroku/node-js-sample\"<br> },<br> â€œkeywordsâ€: [<br> â€œnodeâ€,<br> â€œherokuâ€,<br> â€œexpressâ€<br> ],<br> â€œauthorâ€: â€œMark Pundsackâ€,<br> â€œcontributorsâ€: [<br> â€œZeke Sikelianos &lt;zeke@sikelianos.com&gt; (http://zeke.sikelianos.com)\"<br> ],<br> â€œlicenseâ€: â€œMITâ€<br>}</pre>\n<p>In this above mentioned package.json we have script tag and having start task, so npm scripts enable execution of this tasksÂ using</p>\n<p>npm run start will run nodeÂ index.js</p>\n<h3>Question 7</h3>\n<p>What is Event-driven programming? And how Node JS is event drivenÂ language</p>\n<p>From the name itself its clean that what is event driven something driven by some event so in node js we can write events can trigger something once those eventÂ occurs</p>\n<p>Event driven programmingÂ : Node js is having event loop on single thread and there is always one event will be running and always there will be one handle to handle that event without interruption.</p>\n<p>Before getting into code of eventEmitter we should understand why event loop is best example of event driven programming.</p>\n<p>Event loop perform two operation in aÂ loop</p>\n<pre><strong>var</strong> events = require(â€˜eventsâ€™);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();<br>//Create an event handler:<br><strong>var</strong> EventHandler = <strong>function</strong> () {<br> console.log(â€˜I hear a voice!â€™);<br>}<br>//Assign the event handler to an event:<br>eventEmitter.on(â€˜â€™horrorâ€™â€™, EventHandler);<br>//Fire the â€˜screamâ€™ event:<br>eventEmitter.emit(â€˜horrorâ€™)</pre>\n<ol>\n<li>Event detection</li>\n<li>Event handler triggering</li>\n</ol>\n<p>There can be different events like on database read do that or on doing this successfully after that run thisÂ code.</p>\n<p>Those things can be done using events, event is a core modules where we can emit event from one place and can define handler which can take care of handling thatÂ event.</p>\n<p>Example below showing events by extending <strong>EventEmitter</strong> class, its code sample using classes where we have created custom event emitter by extending EventEmitter class and emitting event and capturing it.</p>\n<pre><strong>const</strong> EventEmitter = require(â€˜eventsâ€™);<br><strong>class</strong> <strong>MyEmitter</strong> <strong>extends</strong> <strong>EventEmitter</strong> {}<br><strong>const</strong> CustomEmitter = <strong>new</strong> MyEmitter();<br>CustomEmitter.on(â€˜eventâ€™, <strong>function</strong>(a, b) {<br> console.log(â€˜processed in first iterationâ€™,a,b);<br>});<br>CustomEmitter.emit(â€˜eventâ€™, â€˜Hiâ€™, â€˜Helloâ€™);</pre>\n<h3>Question 8</h3>\n<p>How Node JS V8 runtime is different from what we have on chromeÂ console</p>\n<p>Chrome console and Node js both are using V8 javascript runtime engine but major difference is Node JS using other c++ core libraries to manage http and socket communication and Chrome V8 engine is mainly browser oriented environments where node js is browserless environment mainly CLI based to executeÂ tasks.</p>\n<p>On browser we have access to window, document and console objects and in Node js we donâ€™t have document &amp; window objects available, it is server side runtime environment which can be executed from command line. Node js mainly used for creating HTTP server, socket communication or reading or writing real timeÂ data.</p>\n<h3>Question 9</h3>\n<p>What is the difference between Asynchronous function, Synchronous function or pure functions</p>\n<p><strong>Synchronous function</strong>Â : Those function which do simple execution and donâ€™t deal with I/O, These are simple function where we can predict output also and have only basic operation having data manipulation</p>\n<p><strong>Asynchronous Function</strong>Â : Special function which deals with network I/O operations like database read, file read or getting data from some api. These operation always takes time while executing and you do not receive instant response from theseÂ api.</p>\n<p>simple example asynchronous code sampleÂ :</p>\n<pre><strong>var</strong> userDetails;<br><strong>function</strong> <strong>initialize</strong>() {<br> // Setting URL and headers for request<br><strong>var</strong> options = {<br> url: â€˜https://api.github.com/users/narenaryan'<br> };<br><strong>return</strong> <strong>new</strong> Promise(<strong>function</strong>(resolve, reject) {<br> // Do async job<br> request.get(options, <strong>function</strong>(err, resp, body) {<br><strong>if</strong> (err) {<br> reject(err);<br> } <strong>else</strong> {<br> resolve(JSON.parse(body));<br> }<br> })<br> })<br>}</pre>\n<pre><strong>// Synchronous code sample</strong></pre>\n<pre><strong>function</strong> <strong>foo</strong>(){}<br><strong>function</strong> <strong>bar</strong>(){<br> foo();<br>}<br><strong>function</strong> <strong>baz</strong>(){<br> bar();<br>}<br>baz();</pre>\n<h3>Question 10</h3>\n<p>what are different options to write asynchronous code inÂ Node.</p>\n<blockquote>\n<strong>Using setTimeout</strong> we can run some code after definedÂ time</blockquote>\n<blockquote>\n<strong>Using callback</strong>Â : return function from another function after asynchronous task isÂ over.</blockquote>\n<blockquote>\n<strong>Using Async moduleÂ </strong>: async module in nodeÂ js</blockquote>\n<blockquote>\n<strong>Using promises</strong>Â : using native promises and wait until promise isÂ resolved</blockquote>\n<blockquote>Using some library like b<strong>luebird,Q library</strong>.</blockquote>\n<blockquote>\n<strong>Using async/await</strong>Â : write less line of code by using asyncÂ await</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=73c2b87c6ae3\" width=\"1\" height=\"1\">\n",
          "content": "\n<h3>50 Essential Node-JS Interview Questions-Part-#1</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*37d-Wo6TFWi6oaXR\"></figure><h3>Question 1</h3>\n<p>What is NPM &amp; how its being used with NodeÂ JS</p>\n<p>npm is the package manager for JavaScript based application and the worldâ€™s largest software registry having thousands of javascript modules.You can Discover packages of reusable codeâ€Šâ€”â€Šand assemble them in powerful newÂ ways.</p>\n<p>NPM is powerful package manager to install new package for your application. It will give you common jsÂ modules.</p>\n<p>NPM gives you capability to initialize application using package.json.</p>\n<p>NPM and yarn are most popular package manager to manage javascript modules.If you are creating some reusable code and wanted to share with others you can create NPM module and push in to NPM and that module can be used byÂ others.</p>\n<pre>npm init</pre>\n<pre>npm install -save react</pre>\n<pre>npm instal -g webpack</pre>\n<pre>npm instal â€” save-dev gulp</pre>\n<p>We can install package globally, Locally and install package in dev dependencies.</p>\n<p>Global packages will be available system wide and can be accessed on system cli like webpack and webpack-dev-server modules.</p>\n<p>npm as package manager install new package for application which can be added globally locally in your application as local module or local dependencies.</p>\n<p>Node js is using NPM and its coming with node version as default package manager to manage dependencies locally and globally.</p>\n<h3>Question 2</h3>\n<p>What is Node.JS? When should we use NodeÂ JS</p>\n<p>Node.js is a server side language based on Googleâ€™s V8 JavaScript engine.</p>\n<p>It is used to build scalable programs and need to run very fast. Its built on top of V8 runtime engine whose baseline in libio &amp; libuv Libraries for cÂ ++.</p>\n<p>Node js can be used to build api and application required real time interface like reading live data, streaming data and doing socket communication.</p>\n<p>Node js should never be used with CPU intensive tasks like reading huge files and reading lot of data from database and sending it somewhere else.</p>\n<p>Node.js is a highly efficient which can scale enough &amp; provide non-blocking I/O running on single thread event loop that was built on top of Google Chrome V8 engine and its ECMAScript.</p>\n<ul>\n<li>Node JS provide scalable applications</li>\n<li>Node JS is server side javascript and single threaded.</li>\n<li>Node JS adds non I/O blocking platform.</li>\n<li>Node JS is built on top of v8 chromeÂ engine.</li>\n<li>Node JS provides faster way to create REST APIs and have good stack of library to support applications.</li>\n<li>Node JS providing faster application development and can be used in microservices like environments.</li>\n</ul>\n<h3>Question 3</h3>\n<p>What is of Node js platform stack, what are different libraries it isÂ using.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/256/0*8D6zO4umZz-oBEPT\"></figure><p>Node JS using V8 runtime Engine same as chrome is using, it built on top of same chromeÂ engine.</p>\n<p>Itâ€™s an open source JIT(Just In Time) compiler written in c++ which has outperformed PHP, Ruby and python performance wise. V8 compiler compiles Javascript directly into assembly level code. V8 Runtime environment comprises into 3 major component</p>\n<p>CompilerÂ : dissects the JSÂ code</p>\n<p>OptimizerÂ : Optimizer called crankshaft create abstract syntax tree(AST) which further converts to SSAÂ : static single assignment and gets optimized</p>\n<p>Garbage CollectorÂ : it removes dead objects from new space and puts into old space. Garbage collector play vital role in keeping Node Js lightweight.</p>\n<p>Base library are c++ library and libeio managing thread pool so javascript engine here is single thread but internally its managing threadÂ pool.</p>\n<p>2. Libuv/libioÂ : A C++Â library</p>\n<p>This library handles Nodeâ€™s asynchronous I/O operation and main event loop. There are thread pool reserve in Libuv which handles the thread allocation to individual I/O operations.</p>\n<p>On top of c++ library node js has binding with http, socket io binding which are being invoked by core modules of node js like fs, net, dns, socket.io, http.</p>\n<p>Node js standard library are written in javascript to access c++ library interface and access interface as Node js will be running on server not on simple browser accessing html and javascript.</p>\n<h3>Question 4</h3>\n<p>What is Node JS Architecture.</p>\n<p>Node is single threaded and based on non I/O blocking way of dealing with operation.</p>\n<p>It is fast and scalable while running on single thread and doing I/O operation like database read, file read in asynchronous way using eventÂ loop.</p>\n<p>Node JS is single threaded or its javascript interface is single threaded, but this is a half truth, actually it is event-driven and single-threaded with background workers. The Event loop is single-threaded but most of the I/O works run on separate threads, because the I/O APIs in Node.js are asynchronous/non-blocking by design, in order to accommodate the eventÂ loop.</p>\n<p>Node js event loop is feature of Node js base library, Node js is running on single threaded environment and can provide more performance using this single threaded event driven model, Node js manages event loop keeps running in search of asynchronous request.</p>\n<p>Node js event loop keeps running and whenever any asynchronous request comes its places in event loop if event loop is not busy and gets processed and further notified once execution over, Once you are getting multiple async requests then it pushed all request to event queue and start processing request one by one without blocking the code execution.</p>\n<p>Event loop is a part of Libeio library and running as single thread keeps waiting for async request ina cycle once it sees anything coming it will processÂ it.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*VOFPFmZjhWpUXXhH\"></figure><h3>Question 5</h3>\n<p>Explain in depth about event loop mechanism in NodeÂ JS.</p>\n<p>The Event Loop is a queue of callback functions. When an async function executes like setTimeout, the callback function is pushed to the queue. The JavaScript engine doesnâ€™t continue processing the event loop until the code after an async function has executed.</p>\n<p>Event-loop is the main part of the node js system. it keeps running and executing as long as node js process are active in memory. Itâ€™s responsible for handling asynchronous operations in application like http call, I/O operation and database read. These all request will be queued to the event loop waiting to be executed on the next free I/O, on execution completion the event loop will got notified to trigger a callback to the main function.</p>\n<pre>request(â€˜http://www.google.com', function(error, response, body) {</pre>\n<pre>console.log(body);</pre>\n<pre>});<br>console.log(â€˜Done!â€™);</pre>\n<p>In above code example, using request module we are making an http call on google.com url. It is asynchronous operation as you will reading data from network. This task will be pushed to event queue if event loop is busy in processing tasks &amp; further once event loop if free, event queue will send that I/O request to event loop for execution. we will get response from the callback added in this code, it will get executed once we have response from I/OÂ task.</p>\n<p>Node js runtime execution is not blocked by asynchronous tasks, it will move to the next statement like in above example after running http call using request module it will move to console.log statement. we will see output on console and after sometime we will be notified with this callback with data coming from networkÂ request.</p>\n<h3>Question 6</h3>\n<ol><li>What is the role of package.json and what are NPMÂ scripts</li></ol>\n<p>This file package.json has the information about the project. this gives information to npm that allows it to identify the project as well as handle the projectâ€™s dependencies either local or devdependencies.</p>\n<p>Some of the fields are basic information like name, name, description, author and dependencies, script and some metaÂ tags.</p>\n<p>if you install application using npm then all the dependencies listed will be installed as well. Additionally, after installation it create./node_modules directory.</p>\n<p>Package.json is just json file having meta information about application. Here main part is npm scripts which are important part and will be executing our application with different commands. Like running node js process either we write node index.js on terminal directly or we just run npm runÂ start.</p>\n<p>Which one isÂ better</p>\n<p>We use npm scripts to automate our tasks and list all them together in npm scripts where we can execute them using npm run &lt;task-name&gt;, npm scripts are powerful you can add pre and post hooks for these tasks. These will work like task runners we used to have like gulp andÂ grunt.</p>\n<pre>{<br> â€œnameâ€: â€œnode-js-sampleâ€,<br> â€œversionâ€: â€œ0.2.0â€,<br> â€œdescriptionâ€: â€œA sample Node.js app using Express 4â€,<br> â€œmainâ€: â€œindex.jsâ€,<br> â€œscriptsâ€: {<br> â€œstartâ€: â€œnode index.jsâ€<br> },<br> â€œdependenciesâ€: {<br> â€œexpressâ€: â€œâ´.13.3â€<br> },<br> â€œenginesâ€: {<br> â€œnodeâ€: â€œ4.0.0â€<br> },<br> â€œrepositoryâ€: {<br> â€œtypeâ€: â€œgitâ€,<br> â€œurlâ€: â€œhttps://github.com/heroku/node-js-sample\"<br> },<br> â€œkeywordsâ€: [<br> â€œnodeâ€,<br> â€œherokuâ€,<br> â€œexpressâ€<br> ],<br> â€œauthorâ€: â€œMark Pundsackâ€,<br> â€œcontributorsâ€: [<br> â€œZeke Sikelianos &lt;zeke@sikelianos.com&gt; (http://zeke.sikelianos.com)\"<br> ],<br> â€œlicenseâ€: â€œMITâ€<br>}</pre>\n<p>In this above mentioned package.json we have script tag and having start task, so npm scripts enable execution of this tasksÂ using</p>\n<p>npm run start will run nodeÂ index.js</p>\n<h3>Question 7</h3>\n<p>What is Event-driven programming? And how Node JS is event drivenÂ language</p>\n<p>From the name itself its clean that what is event driven something driven by some event so in node js we can write events can trigger something once those eventÂ occurs</p>\n<p>Event driven programmingÂ : Node js is having event loop on single thread and there is always one event will be running and always there will be one handle to handle that event without interruption.</p>\n<p>Before getting into code of eventEmitter we should understand why event loop is best example of event driven programming.</p>\n<p>Event loop perform two operation in aÂ loop</p>\n<pre><strong>var</strong> events = require(â€˜eventsâ€™);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();<br>//Create an event handler:<br><strong>var</strong> EventHandler = <strong>function</strong> () {<br> console.log(â€˜I hear a voice!â€™);<br>}<br>//Assign the event handler to an event:<br>eventEmitter.on(â€˜â€™horrorâ€™â€™, EventHandler);<br>//Fire the â€˜screamâ€™ event:<br>eventEmitter.emit(â€˜horrorâ€™)</pre>\n<ol>\n<li>Event detection</li>\n<li>Event handler triggering</li>\n</ol>\n<p>There can be different events like on database read do that or on doing this successfully after that run thisÂ code.</p>\n<p>Those things can be done using events, event is a core modules where we can emit event from one place and can define handler which can take care of handling thatÂ event.</p>\n<p>Example below showing events by extending <strong>EventEmitter</strong> class, its code sample using classes where we have created custom event emitter by extending EventEmitter class and emitting event and capturing it.</p>\n<pre><strong>const</strong> EventEmitter = require(â€˜eventsâ€™);<br><strong>class</strong> <strong>MyEmitter</strong> <strong>extends</strong> <strong>EventEmitter</strong> {}<br><strong>const</strong> CustomEmitter = <strong>new</strong> MyEmitter();<br>CustomEmitter.on(â€˜eventâ€™, <strong>function</strong>(a, b) {<br> console.log(â€˜processed in first iterationâ€™,a,b);<br>});<br>CustomEmitter.emit(â€˜eventâ€™, â€˜Hiâ€™, â€˜Helloâ€™);</pre>\n<h3>Question 8</h3>\n<p>How Node JS V8 runtime is different from what we have on chromeÂ console</p>\n<p>Chrome console and Node js both are using V8 javascript runtime engine but major difference is Node JS using other c++ core libraries to manage http and socket communication and Chrome V8 engine is mainly browser oriented environments where node js is browserless environment mainly CLI based to executeÂ tasks.</p>\n<p>On browser we have access to window, document and console objects and in Node js we donâ€™t have document &amp; window objects available, it is server side runtime environment which can be executed from command line. Node js mainly used for creating HTTP server, socket communication or reading or writing real timeÂ data.</p>\n<h3>Question 9</h3>\n<p>What is the difference between Asynchronous function, Synchronous function or pure functions</p>\n<p><strong>Synchronous function</strong>Â : Those function which do simple execution and donâ€™t deal with I/O, These are simple function where we can predict output also and have only basic operation having data manipulation</p>\n<p><strong>Asynchronous Function</strong>Â : Special function which deals with network I/O operations like database read, file read or getting data from some api. These operation always takes time while executing and you do not receive instant response from theseÂ api.</p>\n<p>simple example asynchronous code sampleÂ :</p>\n<pre><strong>var</strong> userDetails;<br><strong>function</strong> <strong>initialize</strong>() {<br> // Setting URL and headers for request<br><strong>var</strong> options = {<br> url: â€˜https://api.github.com/users/narenaryan'<br> };<br><strong>return</strong> <strong>new</strong> Promise(<strong>function</strong>(resolve, reject) {<br> // Do async job<br> request.get(options, <strong>function</strong>(err, resp, body) {<br><strong>if</strong> (err) {<br> reject(err);<br> } <strong>else</strong> {<br> resolve(JSON.parse(body));<br> }<br> })<br> })<br>}</pre>\n<pre><strong>// Synchronous code sample</strong></pre>\n<pre><strong>function</strong> <strong>foo</strong>(){}<br><strong>function</strong> <strong>bar</strong>(){<br> foo();<br>}<br><strong>function</strong> <strong>baz</strong>(){<br> bar();<br>}<br>baz();</pre>\n<h3>Question 10</h3>\n<p>what are different options to write asynchronous code inÂ Node.</p>\n<blockquote>\n<strong>Using setTimeout</strong> we can run some code after definedÂ time</blockquote>\n<blockquote>\n<strong>Using callback</strong>Â : return function from another function after asynchronous task isÂ over.</blockquote>\n<blockquote>\n<strong>Using Async moduleÂ </strong>: async module in nodeÂ js</blockquote>\n<blockquote>\n<strong>Using promises</strong>Â : using native promises and wait until promise isÂ resolved</blockquote>\n<blockquote>Using some library like b<strong>luebird,Q library</strong>.</blockquote>\n<blockquote>\n<strong>Using async/await</strong>Â : write less line of code by using asyncÂ await</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=73c2b87c6ae3\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "interview",
              "nodejs",
              "questions",
              "javascript"
          ]
      }
  ]
}

export default blogData;